# HTTP 2.0

- HTTP/2.0
- 만들기 시작한 배경
- HTTP/1.1과의 주요 차이점
- 현재까지 알려진 보안 이슈
- 8번째 초안에 기반된 내용



## 1. HTTP/2.0의 등장 배경

```
HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화  
그러다 보니 성능은 희생되었다.  

1. 커넥션 하나를 두고 하나의 요청에 대해 하나의 응답만 받는 HTTP 메시지 교환 방식 - 회전 지연
2. 병렬 커넥션, 파이프라인 커넥션 도입 - 성능 개선의 근본적인 해결책은 되지 못했다.

성능 문제를 위한 노력이 계속되고 있다.
```



**회전 지연을 줄이기 위한 노력 -> 구글의 SPDY -> HTTP/2.0 설계**

```
HTTP 속도를 개선하기 위한 여러기능 추가
- 헤더 압축하여 대역폭 절약
- 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄임
- 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스 추가

SPDY가 실제로 성능 개선 효과가 있어서 이를 바탕으로 HTTP/2.0 프로토콜이 설계되고 있다. 
```



## 2. 개요

```
HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다. 이때 TCP커넥션을 초기화하는 것은 클라이언트다.
```

- HTTP/2.0의 요청과 응답
  - 길이가 정의된(최대 16383바이트) **한 개 이상의 프레임에** 담긴다.
  - 이 때 **HTTP 헤더는 압축**된다.

- 프레임들에 담긴 요청과 응답은 **스트림**을 통해 보내진다.
- 한 개의 스트림이 **한 쌍의 요청과 응답 처리**
- 하나의 커넥션 위에 **여러개의 스트림이 동시에 만들어짐**
- **여러개의 요청과 응답을 동시에 처리**하는것이 가능하다. 
- **서버 푸시**
  - 서버가 클라이언트에게 필요하다고 생각하는 리소스라면 **요청을 명시적으로 받지 않더라도 능동적으로 클라이언트에게 보냄**
  - ex) html페이지를 꾸미는 기타 css, js들
- 호환성
  - HTTP/1.1과 요청과 응답 메시지의 **의미를 같게함**
  - Content-Length, 404 Not Found 등 
  - **문법은 변경되었음**



## 3. HTTP/1.1과의 차이점

### 3.1 프레임

```bash
HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송된다. 
모든 프레임은 8바이트 크기의 헤더로 시작하며, 뒤이어 최대 16383 바이트 크기의 페이로드가 온다. 
```

- R : 예약된 2비트 필드, 반드시 0
- 길이 : 페이로드의 길이를 나타내는 14비트 무부호 정수 (길이에 헤더 포함x)
- 종류 : 프레임의 종류
  - DATA, HEADERS, PRIORITY, RST_STREAM, SETTINGS, PUSH_PROMISE, PING, GOAWAY, WINDOW_UPDATE, CONTINUATION
- 플래그 : 8비트 플래그 , 프레임의 종류에 따라 다름
- R : 예약된 1비트 필드 , 반드시 0
- 스트림 식별자 : 31비트 스트림 식별자
  - 0은 커넥션 전체와 연관된 프레임을 의미



### 3.2 스트림과 멀티플렉싱

```bash
스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 `양방향` 시퀀스이다.
```

한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진다.  
클라이언트는 새 스트림을 만들어 그를 통해 HTTP 요청을 보내고 요청을 받은 서버는 그 요청과 같은 스트림으로 응답을 보낸다. 그러면 닫히게 된다.  

- HTTP/1.1
  - 한 TCP 커넥션에서 요청에 대한 응답이 도착하고 나서야 다시 요청을 보낼 수 있다
  - 병렬, 파이프라인을 사용해도 무한정으로 만들 수는 없어서 회전 지연을 피하기 어렵다.
- HTTP/2.0
  - **하나의 커넥션에 여러개의 스트림이 동시에 열릴 수 있다.** (SETTINGS-SETTINGS_MAX_CONCURRENT_STREAMS로 값 조절)
  - **하나의 커넥션을 통해 여러개의 요청이 동시에** 보내질 수 있다. 
  - 우선순위도 가질 수 있다.
    - 의무사항이 아니라서 보장은 안된다.
  - 모든 스트림은 31비트 무부호 식별자를 갖는다.
    - 클라이언트에 의해 초기화 되었다면 식별자는 반드시 **홀수**
    - 서버에 의해 초기화되었다면 식별자는 반드시 **짝수**
    - 새로 만들어지는 식별자는 이전 식별자보다 커야한다. 
    - 규칙을 어기면 PROTOCOL_ERROR 커넥션 에러
    - 서버와 클라이언트는 스트림을 **협상 없이** 받아 TCP처럼 연결패킷 주고받는 시간낭비가 없다.
    - 커넥션에서 한번 사용한 스트림은 **재사용이 불가능**하다.
      - 식별자가 고갈되면 커넥션 다시 맺음
    - WINDOW_UPDATE프레임을 이용한 흐름제어

### 3.3 헤더 압축

```
HTTP/1.1에서 헤더는 아무런 압축없이 그대로 전송되었다.   
요즘 웹페이지 하나를 만들기 위한 요청이 많기 때문에 헤더의 크기가 회전지연과 대역폭 양쪽 모두에 실질적인 영향을 끼친다.
```

HTTP/2.0에서는 **HTTP 메시지의 헤더를 압축하여 전송한다.**  

- 압축 콘텍스트 사용 - 호프만 코딩
  - 올바른 압축 콘텍스트 유지해야한다. 
  - 수신한 헤더의 압축을 풀면 영향을 받아 바뀜
  - 송신측은 수신측이 헤더의 압축을 풀었으며 그에 따라 압축 콘텍스트가 변겨오디었다고 가정할 것이다.
  - 헤더를 받은 수신측은 어떤 경우에도 반드시 압축 해제를 수행해야한다.
  - 그럴 수 없다면 COMPRESSION_ERROR와 함께 커넥션을 끊어야함

- 헤더의 중복되는 필드를 재전송하지 않도록 하여 데이터를 절약한다.

### 3.4 서버 푸시

HTTP/2.0은 서버가 하나의 요청에 대해 **응답으로 여러개의 리소스를 보낼 수 있도록 해준다.**  

- ex) HTML 문서가 링크하고 있는 css, 이미지, javascript파일 등 리소스를 푸시   
- 클라이언트가 필요한 리소스를 다시 요청하며 발생하는 트래픽, 회전 지연을 줄여준다.   



리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시할것임을 PUSH_PROMISE 프레임을 보내어 알려주어야 한다.   
또 클라이언트는 RST_STREAM으로 푸시를 거절할 수도 있다. 그러면 스트림은 즉각 닫히게 된다.  

- 서버 푸시를 사용하기로 했더라도 중간에 프락시가 전달하지 않을 수도 있고, 서버로부터 오지 않았더라도 프락시가 클라이언트에게 전달할 수도 있다.
- 서버는 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시 할 수 있다.
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야한다.
  - 프레임은 원 요청을 위해 만들어진 스트림을 통해 보내진다.
- 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책에 따라 검사해야한다.
- 서버 푸시를 끄고싶다면 SETTINGS_EANABLE_PUSH = 0



## 4. 알려진 보안 이슈

### 4.1 중개자 캡슐화 공격

```
HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1메시지로 변환할 때 메시지의 의미가 변경될 가능성이 있다.
HTTP/2.0은 헤더필드를 바이너리로 인코딩하는데 이 때 줄바꿈이나 어떤 문자열이든 허용한다. 
정상적인 2.0 요청이나 응답이 위조된 HTTP/1.1메시지로 번역될 가능성이 있다.

HTTP/1.1 -> HTTP/2.0은 문제가 발생하지 않는다.
```



### 4.2 긴 커넥션 유지로 인한 개인정보 누출 유려

```
HTTP/2.0은 사용자가 요청을 보낼 때 회전 지연을 줄이기 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두에 두고 있다.  

개인 정보의 유출에 악용될 가능성이 있다. 
이전 브라우저를 사용했던 사용자가 무엇을 했는지 알아낼 수도 있다.
```





