# 12장. 기본 인증

```bash
웹을 통해 얻는 정보나 업무가 공용은 아니기 때문에, 허가된 사람만이 데이터에 접근하고 업무를 처리할 수 있어야한다.

그러기 위해서 서버가 사용자가 누구인지 식별할 수 있어야한다.   

보통 사용자 이름과 비밀번호를 입력해서 인증한다. HTTP는 자체적인 인증관련 기능을 제공한다. 
- 요즘엔 HTTP 자체 인증보다는 각각의 인증 모듈을 이용해 직접 구현하는 추세이다.\

HTTP의 `Basic`인증을 알아본다.
```



## 1. 인증

```
인증은 당신이 누구인지 증명하는 것이다.
```

### 1.1 HTTP 인증요구/ 응답 프레임워크

HTTP는 사용자 인증을 하는데 사용하는 자체 인증요구/응답 프레임워크를 제공한다.

![img](https://bebiangel.github.io/images/http-guide-chap12.png)  

출처 https://bebiangel.github.io/2019/11/24/http-guide-chap12/

- 웹 어플리케이션이 HTTP 요청을 받으면 서버는 요청을 처리하는 대신에 현재 사용자가 누구인지를 알 수 있게 비밀번호 같이 개인정보를 요구하는 `인증 요구`로 응답할 수 있다.
- 사용자가 다시 요청을 보낼 때는 인증정보(사용자 이름, 비밀번호)를 첨부해야한다. 만약 인증 정보가 맞지 않으면 서버는 클라이언트에 다시 인증요구를 보내거나 에러를 낼 수 있다. 
- 인증정보가 맞으면 요청은 문제없이 처리가 완료된다.



### 1.2 인증 프로토콜과 헤더

```
HTTP는 필요에 따라 고쳐쓸 수 있는 제어 헤더를 통해, 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공한다.   
표에 나열된 헤더의 형식과 내용은 인증 프로토콜에 따라 달라진다. 인증 프로토콜은 HTTP인증 헤더에 기술되어 있다.

HTTP에는 Basic인증과 다이제스트 인증이라는 두가지 공식적인 인증 프로토콜이 있다. 현대에는 OAuth등이 있다. 
```

**Basic 인증**

| 단계      | 헤더                | 설명                                                         | 메서드/상태      |
| --------- | ------------------- | ------------------------------------------------------------ | ---------------- |
| 요청      |                     | 첫 번째 요청에는 인증 정보가 없다.                           | GET              |
| 인증 요구 | WWW-Authenticate    | 서버는 사용자에게 사용자 이름과 비밀번호를 제공하라는 지시의 의미로 401상태정보와 함께 요청을 반려한다.<br />서버에는 각각 다른 비밀번호가 있는 영역이 있을 것이므로, 서버는 WWW-Authenticate 헤더에 해당 영역을 설명해 놓는다. | 401 Unauthorized |
| 인증      | Authorization       | 클라이언트는 요청을 다시 보내는데, 이번에는 인증 알고리즘과 사용자 이름과 비밀번호를 기술한 Authorization헤더를 함께 보낸다. | GET              |
| 성공      | Authentication-Info | 인증 정보가 정확하면, 서버는 문서와 함께 응답한다. <br />어떤 인증 알고리즘은 선택적인 헤더인 AUthentication-Info에 인증 세션에 관한 추가 정보를 기술해서 응답하기도 한다. | 200 OK           |

![img](https://mdn.mozillademos.org/files/14689/HTTPAuth.png). 

- 서버가 사용자에게 인증 요구를 보낼때 서버는 401 Unauthorized 응답과 함께 WWW-Authenticate 헤더를 기술해서 어디서 어떻게 인증할지 설명한다.
- 다음으로 클라이언트가 서버로 인증하려면, 인코딩된 비밀번호와 그 외 인증 파라미터들을 Authorization 헤더에 담아서 요청을 다시 보낸다.
- 인증 요청이 성공적으로 완료되면, 서버는 정상적인 상태 코드를 반환하며, 추가적인 인증 알고리즘에 대한 정보를 Authentication-Info 헤더에 기술할 수도 있다.

### 1.3 보안 영역

```
기본 인증을 살펴보기에 앞서, HTTP가 어떻게 각 리소스마다 다른 접근 조건을 다루는지 설명할 필요가 있다.
서버가 클라이언트로 인증요구를 할 때 realm 지시자가 기술되어 있는 WWW-Authenticate 헤더를 봤을 것이다.  
웹 서버는 기밀문서를 보안영역 그룹(relam)으로 나눈다. 보안영역은 저마다 다른 사용자 권한을 갖는다.  
```



## 2. 기본 인증

```
기본 인증은 가장 잘 알려진 HTTP 인증 규약이다. 거의 모든 주요 클라이언트와 서버에 기본 인증이 구현되어있다.
기본 인증은 원래 HTTP/1.0에 기술되어 있었지만, HTTP 인증의 상세 내용을 다루는 RFC 2617로 옮겨졌다. 

기본 인증에서, 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비밀번호를 요구할 수 있다.
서버는 200 대신 401 상태코드와 함께, 클라이언트가 접근하려고 했던 보안 영역을 WWW-Authenticate에 기술해서 응답하여 인증요구를 시작한다. 
인증정보를 포함하여 요청하라는 응답을 받은 브라우저는, 사용자에게 계정과 비밀번호를 입력할 수 있는 대화상자를 연다.
여기서 계정과 비밀번호는 사용자가 해당 영역에 접근권한이 있는지 검사하는데 사용한다.
브라우저는 사용자가 입력한 사용자 이름과  비밀번호를 Authorization요청 헤더 안에 암호화해서 서버로 다시 보낸다.
```

| 인증 요구 /응답             | 헤더 문법과 설명                                             |
| --------------------------- | ------------------------------------------------------------ |
| 인증 요구(서버->클라이언트) | 각 사이트는 보안 영역마다 다른 비밀번호가 있을 것이다. <br />realm은 요청받은 문서 집합의 이름을 따옴표로 감싼 것으로, 사용자는 이 정보를 보고 어떤 비밀번호를 사용해야 하는 지 알 수 있다. <br />`WWW-Authenticate: Basic realm=따옴표로 감싼 문서 집합 정보` |
| 응답(클라이언트->서버)      | 사용자 이름과 비밀번호를 콜론으로 잇고, base-64로 인코딩해서 사용자 이름과 비밀번호에 쉽게 국제문자를 포함할 수 있게 하고, 네트워크 트래픽에 사용자 이름과 비밀번호가 노출되지 않게 한다. <br />`Authorization: Basic base-64로 인코딩한 사용자 이름과 비밀번호` |

(기본 인증 프로토콜은 Authentication-Info헤더를 사용하지 않는다. )



### 2.2 Base-64 사용자 이름/비밀번호 인코딩

```
HTTP 기본 인증은 사용자 이름과 비밀번호를 콜론으로 이어서 합치고, `base-64`인코딩 메서드를 사용해 인코딩한다.

# base-64 인코딩
8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환한다. 
각 6비트 조각은 대부분 문자와 숫자로 이루어진 특별한 64개의 문자중에서 선택된다. 
brian-totty:Ow! -> YnJpYW4tdG90dHk6T3ch
```

**Base-64인코딩은 문자열을 전송 가능한 문자인 알파벳으로 변환하기 위해 발명되었다. 전송중에 원본 문자열이 변질될 걱정 없이 원격에서 디코딩할 수 있다. 또한 서버나 네트워크를 관리하면서 뜻하지 않게 사용자 이름과 비밀번호가 노출되는 문제를 예방하는데 도움이 된다.**



### 2.3 프락시 인증

```
중개 프락시 서버를 통해 인증할 수도 있다. 사용자들이 회사의 서버나 LAN이나 무선 네트워크에 접근하기 전에 프락시 서버를 거치게 하여 사용자를 인증한다. 
프락시 서버에서 접근 정책을 중앙관리할 수 있기 때문에 회사 리소스 전체에 대한 통합 접근 제어를 하기 위해서 프락시 서버를 사용하면 좋다. 
```

| 웹 서버                | 프락시 서버               |
| ---------------------- | ------------------------- |
| 비인증 상태 코드 : 401 | 407                       |
| WWW-Authenticate       | Proxy-Authenticate        |
| Authorization          | Proxy-Authorization       |
| Authentication-Info    | Proxy-Authentication-Info |



## 3.기본 인증의 보안 결함

```
기본 인증은 단순하고 편리하지만 안심할 수는 없다.  
기본 인증은 악의적이지 않는 누군가가 의도치 않게 리소스를 접근하는 것을 막는데 사용하거나, SSL같은 암호술과 혼용한다.
```



**쉽게 디코딩 가능**  

기본 인증은 사용자 이름과 비밀번호를 쉽게 디코딩할 수 있는 형식으로 네트워크에 전송한다. Base-64를 사용해도 바로 보이지는 않지만 디코딩할 수 있다. base-64로 인코딩 된 비밀번호는 사실상 비밀번호 그대로 보내는 것과 다름 없다. 이게 문제가 된다면 **HTTP 트랜잭션을 SSLh암호화 채널을 통해**보내거나, 보안이 더 강화된 프로토콜을 사용하는 것이 좋다.   

**재전송 공격**     

보안 비밀번호가 디코딩하기에 복잡하게 인코딩 되어있다 하더라도, 사용자 이름과 비밀번호를 캡처하여 그대로 원 서버에 보내서 인증에 성공하고 서버에 접근할 수 있다. 기본인증은 이러한 재 전송 공격을 예방하기 위한 일을 하지 않는다.  

**사용자는 보통 같은 아이디와 비밀번호 사용**  

일반 사용자들은 보통 사이트에 같은 아이디와 비밀번호를 사용한다. 악의를 가진 누군가가 사용자 이름과 비밀번호를 캡처해 다른 중요한 사이트에 접근을 시도해볼 수 있다.

**중간 개입**  

메시지의 인증 헤더를 건드리지는 않지만, 그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프락시나 중개자가 중간에 개입하는 경우, 기본 인증은 정상적인 동작을 보장하지 않는다.  

**가짜 서버의 위장**  

사용자가 가짜 서버나 가짜 게이트웨이에 연결되어있는데도, 사용자는 기본 인증을 수행하는 검증된 서버에 연결되어있다고 믿고 있으면 공격자는 사용자에게 비밀번호를 요청하고 그것을 나중에 사용할 목적으로 저장한 다음 에러가 난 척 할것이다.  



> 기본인증은 일반적 환경에서 개인화나 접근 제어에는 편리함을 제공하며, **다른 사람들이 보지 않기를 원하기는 하지만 보더라도 치명적이지 않은 경우에 여전히 유효하다.**  
>
> 기본인증은 사용자 이름과 비밀번호를 악의적인 개인들에게 숨기려고 암호화된 데이터 전송과 함께 연계해서 사용할 수 있다. -> 14장 