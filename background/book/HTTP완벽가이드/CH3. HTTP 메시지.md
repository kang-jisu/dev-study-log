# HTTP 메시지

## 1. 메시지의 흐름

### 인바운드 / 아웃바운드

- 메시지는 원 서버 방향을 인바운드로 하여 흐른다. 
- 인바운드 : 메시지가 원 서버로 향하는 것
- 아웃바운드 : 처리가 끝난 후에 메시지가 사용자 에이전트로 돌아오는 것

### 업스트림 / 다운스트림

- 요청, 응답에 관계 없이 모든 HTTP 메시지는 **다운스트림**으로 흐른다. 
- 발송자는 수신자의 업스트림이다. 

<br/>

## 2. 메시지의 각 부분

> HTTP 메시지는 단순한 데이터의 구조화된 블록이다. 

- 메시지

  - 시작줄 : 어떤 메시지인지 서술
  - 헤더 : 속성
  - 본문 : 데이터 (없을수도 있음)  

  시작줄과 헤더는 줄 단위로 분리된 아스키 문자열이며, 각 줄은 CRLF(캐리지 리턴과 개행 문자)로 구성된 두 글자의 줄바꿈 문자열로 끝난다.   

  본문은 단순히 선택적인 데이터이며, 텍스트나 이진 데이터를 포함할 수도 있고 비어있을 수도 있다.   

<br/>

### 2.1 메시지 문법

**요청 메시지**

```bash
<메서드> <요청URL> <버전>
<헤더>

<엔티티 본문>
```

**응답 메시지**

```bash
<버전> <상태 코드> <사유 구절>
<헤더>

<엔티티 본문>
```



### 2.2 시작줄

- 모든 HTTP 메시지는 시작줄로 시작한다.
- 요청 메시지의 시작줄은 `무엇을 해야하는지` 를 나타낸다.
  - `<메서드> <요청URL> <버전>` 
- 응답 메시지의 시작줄은 `무엇이 일어났는지`를 말해준다.
  - `<버전> <상태 코드> <사유 구절>`

**메서드**

- 클라이언트 측에서 서버가 리소스에 대해서 수행해주길 바라는 동작
- `GET`, `HEAD`, `POST` 와 같이 한 단어로 되어있다.

```yaml
- GET : 서버에서 어떤 문서를 가져온다. 본문 없음
- HEAD : 서버에서 어떤 문서에 대한 헤더만 가져온다. 본문 없음
- POST : 서버가 처리해야 할 데이터를 보낸다. 본문 "있음"
- PUT : 서버에 요청 메시지의 본문을 저장한다. 본문 "있음"
- TRACE : 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추척한다. 본문 없음 -> 거의안씀
- OPTIONS : 서버가 어떤 메서드를 수행할 수 있는지 확인한다. 본문 없음
- DELETE : 서버에서 문서를 제거한다. 본문 없음 
```

**상태 코드**

- 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자 
- 각 코드의 첫번째 자릿수는 상태의 일반적인 분류(성공, 에러 등)를 나타낸다. 

```yaml
- 1xx (100-101) : 정보
- 2xx (200-206) : 성공
- 3xx (300-305) : 리다이렉션
- 4xx (400-415) : 클라이언트 에러
- 5xx (500-505) : 서버 에러
```

**사유 구절**

- 숫자로된 상태 코드의 의미를 사람이 이해할 수 있게 짧게 설명해주는 문구
- 사람에게 읽히기 위한 목적으로 존재하므로 서로 달라보여도 코드가 같다면 같은 의미로 처리한다.

**버전**

- 메시지에서 사용중인 HTTP 버전 (지원하는 가장 높은 HTTP버전을 가리킨다)
- `HTTP/<메이저>.<마이너>` 형식

**요청 URL**

- 요청 대상이 되는 리소스를 지정하는 완전한 URL 혹은 URL의 경로 

### 2.3 헤더

- 이름, 콜론`(:)`, 선택적 공백, 값, CRLF가 순서대로 나타난다. 
- HTTP/1.1과 같은 몇몇 버전의 HTTP는 요청이나 응답에 특정 헤더가 포함되어야만 유효한 것으로 간주한다. 
- 헤더를 여러 줄로 쪼개 읽기 좋게 나누르면 추가 줄 앞에 하나의 스페이스 혹은 탭 문자가 와야한다. 

**헤더 분류**

- 일반 헤더, 요청 헤더, 응답 헤더, Entity 헤더, 확장 헤더 
- 엔티티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄로 끝나야한다. 

### 2.4 본문

- 임의의 데이터 블록을 포함한다. 
- 여러 종류의 디지털 데이터를 담을 수 있다. 

### 2.5 HTTP/0.9 메시지

메서드와 요청 URL만 가지며 응답은 오직 엔티티로만 되어있다. 버전 정보, 상태 코드, 사유 구절, 헤더가 없다.   

<br/>

## 3. 메서드

모든 서버가 모든 메서드를 구현하지는 않으며 HTTP/1.1과 호환되려면 GET, HEAD만 구현하면 된다. 

### 3.1 안전한 메서드

HTTP의 요청의 결과로 서버에 어떤 작용도 없는 메서드를 의미한다. `GET`과 `HEAD` 는 안전한 메서드이다. 

안전한 메서드의 목적은 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 어플리케이션을 만들 수 있도록 하는 것  

### 3.2 GET

> 서버에게 리소스 요청

HTTP/1.1 에서 반드시 구현되어야 한다. 

### 3.3 HEAD

> 서버는 응답으로 헤더만을 돌려주며 엔티티 본문은 반환되지 않는다.

- 리소스를 가져오지 않고도 그에 대해 무엇인지( ex.타입) 알아내기 위해
- 응답의 상태코드를 통해 개체가 존재하는지 확인
- 헤더를 확인하여 리소스 변경 검사  

HTTP/1.1 에서 반드시 구현되어야 한다.   

### 3.4 PUT

> 서버에 문서를 **쓴다.** 

- 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나 이미 존재한다면 본문을 사용해서 교체한다.

### 3.5 POST

> 서버에 입력 데이터를 **전송**하기 위해 사용한다. 

* POST는 서버에 데이터를 보내기 위해 사용하며 PUT은 서버에 있는 리소스에 데이터를 입력하기 위해 사용된다.  

### 3.6 TRACE 

> 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다. 
>
> 요즘프록시가 워낙 많아서..이거로 확인할수가없음..거의안씀

- 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려준다. 

- 주로 진단을 위해 사용된다. 요청이 의도한 요청/응답 연쇄를 거쳐가는지 검사하고 프록시나 다른 애플리케이션이 요청에 어떤 영향을 미치는지 확인한다. 

- 어떤 본문도 보낼 수 없다. 응답에는 서버가 받은 요청이 그대로 들어있다.

- ```http
  HTTP/1.1 200 OK
  Content-type: text/plain
  Contnet-length: 96
  Via: 1.1 proxy3.company.com
  
  TRACE /product-list.txt HTTP/1.1
  HOST: www.joes-hardware.com
  Accept: *
  Via: 1.1 proxy3.company.com
  ```

### 3.7 OPTIONS

> 웹 서버에게 여러가지 종류의 지원 범위에 대해서 물어본다. 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.   

### 3.8 DELETE

> 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다. 

<br/>

## 4. 상태코드

### 4.1 1xx 정보성 상태코드

HTTP/1.1에서 도입되었다.   

| 상태코드 | 사유 구절             | 의미                                                         |
| -------- | --------------------- | ------------------------------------------------------------ |
| 100      | `Continue`            | - 요청의 시작부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야함. 이것을 보낸 후 서버는 반드시 요청을 받아 응답해야한다. <br/> - header에 'Expect : 100-continue'라고 클라이언트가 보냄 |
| 101      | `Switching Protocols` | - 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음 |



### 4.2 2xx 성공 상태 코드

| 상태코드 | 사유 구절                       | 의미                                                         |
| -------- | ------------------------------- | ------------------------------------------------------------ |
| 200      | `OK`                            | - 요청은 정상이고 엔티티 본문은 요청된 리소스를 포함하고 있다 |
| 201      | `Create`                        | - 개채 생성 요청에 대한 응답<br />- 생성된 리소스의 참조가 담긴 Location 헤더와 함께 리소스를 참조할 수 있는 여러 URL을 본문에 포함한다<br />- 상태 코드를 보내기 전에 반드시 객체를 생성해야 한다. |
| 202      | `Accepted`                      | - 요청은 받아들여졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않았다. <br />- 서버가 요청 처리를 완료할 것이지에 대한 보장이 없다 <br />- 서버는 요청에 대한 상태와 요청의 처리가 언제 끝날 것인지에 대한 추정을 가급적 본문에 포함해야한다. |
| 203      | `Non-Authoritative Information` | - 엔티티 헤더에 들어있는 정보가 리소스의 사본에서 왔다       |
| 204      | `No Content`                    | - 엔티티 본문을 포함하지 않음<br />- 주로 웹 브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때(폼 리프레시) 사용 |
| 205      | `Reset Content`                 | - 브라우저를 위해 사용되는 코드 <br />- 현재 페이지에 있는 HTML 폼에대한 모든 값을 비워라 |
| 206      | `Partial Content`               | - 부분 혹은 범위 요청이 성공했음 <br />- `Content-Range`와 `Date` 헤더를 반드시 포함해야 하며 `Etag`, `Content-Location`중 하나의 헤더도 반드시 포함해야한다. |

### 4.3 3xx 리다이렉션 상태 코드

클라이언트가 원하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스 대신 다른 대안의 응답을 제공한다. 

일반적으로 HEAD가 아닌 요청에 대해 리다이렉션 상태 코드를 포함한 응답을 할 때는 리다이렉트 URL에 대한 정보를 포함시키는 것이 좋다. 

| 상태코드 | 사유 구절            | 의미                                                         |
| -------- | -------------------- | ------------------------------------------------------------ |
| 300      | `Multiple Chocies`   | - 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우 리소스의 목록과 함께 반환 |
| 301      | `Moved Permanently`  | - 요청한 URL이 옮겨졌을 때 사용 . Location헤더에 현재 리소스가 존재하고 있는 URL을 포함<br />예) http요청 보냈을 때 https로 301해줌 |
| 302      | `Found`              | - 301과 같은데 Location에 있는 리소스를 임시로 사용해야한다. 이후의 요청은 원래 URL을 사용해야한다. |
| 303      | `See Other`          | - 리소스를 다른 URL에서 가져와야 한다. <br />- 주 목적은 POST요청에 대한 응답으로 클라이언트에게 리소스의 위치를 알려주는 것 |
| 304      | `Not Modified`       | - 클라이언트가 헤더에 `If-Modified-Since`같은 요청을 보냈을 때 최근에 수정되지 않았다면 이 응답을 반환한다. <br />- 엔티티 본문을 가지지 않는다. |
| 305      | `Use Proxy`          | - 리소스가 반드시 프락시를 통해 접근되어야함                 |
| 306      | -                    | 사용되지않음                                                 |
| 307      | `Temporary Redirect` | - 301과 비슷함. HTTP/1.1에서 HTTP/1.0과 혼란을 막기 위해 302를 307로 대신 사용하길 권고함. <br />- 302 : HTTP/1.0 /  307 : HTTP/1.1 ( 임시 url을 사용하길 원할 때 ) |
|          |                      |                                                              |

### 4.4 4xx 클라이언트 에러 상태 코드

| 상태코드  | 사유 구절                       | 의미                                                         |
| --------- | ------------------------------- | ------------------------------------------------------------ |
| 400       | `Bad Request`                   | - 클라이언트가 잘못된 요청을 보냈다                          |
| 401       | `Unauthorized`                  | - 리소스를 얻기 전에 인증이 필요하다<br />예 : 로그인 전에 요청 |
| 402       | `Payment Required`              | <나중을 위해 비워둠>                                         |
| 403       | `Forbidden`                     | - 요청이 서버에 의해 거부되었다. <br />예 : 로그인 후 어드민이 아닌데 권한없는데 요청 , 남의 회원정보 조회 |
| 404       | `Not Found`                     | - 요청한 URL을 찾을 수 없다.                                 |
| 405       | `Method Not Allowed`            | - 요청 URL에 대해 지원하지 않는 메서드로 요청했다. <br />- Allow 헤더에 지원하는 메서드를 명시해주어야한다. |
| 406       | `Not Acceptable`                | - 요청한 리소스가 클라이언트가 명시한 Accept 범주에 없는 경우 |
| 407       | `Proxy Authentication Required` | - 401과 같으나 인증을 요구하는 프록시 서버를 위해 사용       |
| 408       | `Request Timeout`               | - 클라이언트 요청을 완수하는데 시간이 많이 걸리는 경우 연결을 끊음 |
| 409       | `Conflict`                      | - 요청이 리소스에 대해 일으킬 수 있는 충돌을 지칭            |
| 410 - 417 |                                 | 생략                                                         |

### 4.5 5xx 서버 에러 상태 코드

| 상태코드 | 사유 구절                    | 의미                                                         |
| -------- | ---------------------------- | ------------------------------------------------------------ |
| 500      | `Internal Server Error`      | - 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때       |
| 501      | `Not Implemented`            | - 클라이언트가 서버의 능력을 넘은 요청을 했을 때             |
| 502      | `Bad Gateway`                | - 응답 연쇄에 있는 다음 링크로 부터 가짜 응답에 맞닥뜨렸을 때<br />예 : 서버 죽고 nginx 만 살아있을 때 |
| 503      | `Service Unavaiable`         | - 현재는 서버가 요청을 처리할 수 없지만 나중에는 가능함      |
| 504      | `Gateway Timeout`            | - timeout이 게이트웨이나 프락시에서 온 응답이다.             |
| 505      | `Http Version Not Supported` |                                                              |



<br/>

## 5. 헤더

- 일반 헤더 : 서버와 클라이언트 양쪽 모두 사용

  - ```bash
    - Connection, Date, MIME-Version, Transfer-Encoding, Upgrade, Via 등.. 
    - Cache-Control, Pragma # 일반 캐시 헤더
    ```

- 요청 헤더 : 요청 메세지를 위한 헤더

  - ```bash
    - Client-IP, From, Host, Referer, UA-XX, User-Agent
    - Accept, Accept-Charset, Accept-Encoding, Accept-Language #Accept관련
    - Expect, IF-Match, If-Modified-Since, If-None-Match, If-Range, If-Unmodified-Since, Range # 조건부 요청
    - "Authorization", Cookie # 요청 보안 헤더 
    - Max-Forwards, Proxy-Authorization, Proxy-Connection # 프락시 요청 헤더 
    ```

- 응답 헤더 : 클라이언트에게 정보를 제공하기 위해

  - ```bash
    - Age, Retry-After, Server, Warning
    - Accept-Ranges, Vary #협상 헤더
    - Proxy-Authenticate, "Set-Cookie" 중요, WWW-Authenticate # 응답 보안 헤더 
    ```

  - set cookie에 보낸거 다음 요청에 cookie헤더에 보내라 

- 엔티티 헤더 : 엔티티 본문에 대한 헤더

  - ```bash
    - Allow, Location
    - Content-Type, Content-Encoding, Content-Language, Content-Length, Content-Range 등.. # 콘텐츠 헤더 
    - Etage, Expries, Last-Modified # 엔티티 캐싱 헤더 
    ```

- 확장 헤더 
  - 프록시 헤더는 요즘엔 x-뭐시기 x-Forward-For 이런거 씀
  - 서버입장에서 프록시 말고 실제 클라이언트 아이피 얻고싶을 때. 