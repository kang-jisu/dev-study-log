# 커넥션 관리

내용이 너무 많고 어려워서 최대한 이해하고 정리는 조금만 한다.. 네트워크 수업때 배운 내용 노트에 있는거 추가로 정리만 추가로 해야겠다. 

## 1. TCP 커넥션

- 전 세계 모든 통신은 TCP/IP를 통해 이루어진다. 
- 일단 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.
- URL에서 IP/PORT 추출 - TCP 커넥션 연결 - HTTP 요청 - HTTP 응답 - TCP 커넥션 종료 

### 1.1 신뢰할 수 있는 데이터 전송통로인 TCP

- TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공한다. 
- TCP 커넥션의 한쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 정확히 전달된다. 

### 1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

-  TCP는 IP 패킷(데이터그램)을 통해 데이터를 전송한다. 
- HTTP - (TSL or SSL) - TCP - IP - Network interfaces
- TCP를 세그먼트 단위로 자르고 세그먼트를 IP 패킷(데이터그램)에 담아 전달
  - IP 패킷 헤더 (20바이트)
    - 발신지, 목적지 IP주소, 크기, 기타 플래그
  - TCP 세그먼트 헤더(20바이트)
    - 발신지 목적지 포트번호, TCP 제어 플래그, Sequnece 순서번호, ACK 확인응답 값
  - TCP 데이터 조각 ( 0 or 그 이상의 바이트)

### 1.3 TCP 커넥션 유지

- 컴퓨터는 TCP커넥션을 여러개 가지고 포트번호를 통해서 여러개의 커넥션을 유지한다.
- `발신지 IP주소, 발신지 포트, 수신지 IP주소, 수신지 포트`로 유일한 커넥션을 생성한다. 

### 1.4 TCP 소켓 프로그래밍

- 소켓 API는 TCP, IP의 세부사항을 숨기고 TCP 커넥션 프로그래밍을 할 수 있게 해준다. 

```python
s = socket(parameter) # 연결되지 않은 익명의 새로운 소켓 생성

bind(s, localIp:port ) # 소켓에 로컬 포트 번호와 인터페이스 할당
listen(s,..) # 커넥션을 받아드리기 위해 로컬 소켓에 허용함을 표시 - 서버 , 연결 요청을 대기시키는 과정까지 담당 
s2 = accept(s) # 누군가 로컬 포트에 커넥션 맺기를 기다리다가 받아드들임- 서버 -> 이때 새로운 s2 소켓 할당함 

connect(s, remoteIp:port) # 로컬의 소켓과 원격의 호스트 및 포트 사이에 TCP 커넥션 생성 - 클라이언트

# listen ---- connect오면 ---- accept

n = read(s, buffer, n) # 소켓으로부터 버퍼에 n바이트 읽기 시도
n = write(s, buffer, n) # 소켓으로부터 버퍼에 n바이트 쓰기 시도

close(s) # TCP 커넥션을 완전히 끊음
shutdown(s, ) # TCP커넥션의 입출력만 닫음

getsocketopt(s, ..) # 내부 소켓 설정 옵션값을 읽음
setsocketopt(s,..) # 내부 소켓 설정 옵션값을 변경
```

![이미지](https://static.javatpoint.com/core/images/socket-programming.png)

출처 - https://static.javatpoint.com/core/images/socket-programming.png



## 2. TCP 성능 고려

HTTP 트랜잭션의 성능은 아래 계층인 TCP 성능에 영향을 받는다. 

### 2.1 HTTP 트랜잭션 지연

- 트랜잭션 처리 시간 : TCP 커넥션 설정 + **요청 전송+ 처리 + 응답 메시지** + TCP 커넥션 종료
- 지연 원인
  - DNS 찾기 지언 : URI로 부터 웹 서버의 IP와 Port번호를 알아내는 과정
  - 커넥션 생성 지연 : TCP 커넥션 요청
  - 요청과 응답 지연 : HTTP 요청 전송, 요청메시지 처리, HTTP 응답 
  - 하드웨어, 전송속도, 메시지 크기, 거리 등 
- 요청, 응답 데이터가 엄청 크지 않는 한 HTTP지연은 TCP 네트워크 지연때문에 발생한다.

### 2.2 성능 관련 중요 요소

- 2.3~2.7 - 일반적 TCP관련 지연, 성능상의 문제에 영향을 준다.

### 2.3 TCP 커넥션 핸드셰이크 지연

- **TCP 커넥션 핸드셰이크**
  - 클라이언트는 새로운 TCP 커넥션을 생성하기 위해 작은 TCP 패킷을 보낸다 : `SYN`(커넥션 생성 요청)
  - 서버가 커넥션을 받으면 요청이 받아들여졋음을 의미하는 패킷을 클라이언트에게 보낸다. : `SYN` + `ACK`
  - 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위해 서버에게 확인응답을 보낸다. 이때 데이터를 함께 보낼 수 있다. : `ACK`
- 이 패킷은 HTTP 응답 메시지 하나를 다 담을만큼 큰 경우가 많은데 **HTTP 요청, 응답 이전에 TCP 구성하는데 쓰는 시간이 많다.**

### 2.4 확인응답 지연

- TCP는 성공적인 데이터 전송을 보장하기 위해 자체적인 확인체계를 가진다. 
- 각 세그먼트 수신자는 세그먼트를 온전히 받으면 **확인응답 패킷**을 송신자에게 반환한다. 만약 특정 시간 안에 확인응답을 받지 못한 송신자는 오류로 판단하고 데이터를 다시 전송한다. 
- 확인응답은 크기가 작아 **같은 방향으로 송출되는 데이터 패킷에** **편승(piggyback)**시킨다. 
- **확인응답 지연 알고리즘**
  - 송출할 확인응답을 특정 시간동안 버퍼에 저장해두고 편승시킬 송출 데이터를 찾는다. 
  - 시간안에 찾지 못하면 별도 패킷으로 확인응답을 보낸다. 
- HTTP는 요청과 응답 두가지로 이루어져 **송출 데이터에 편승할 기회가 적다. 따라서 편승 데이터를 찾기 위한 지연이 자주 발생한다.** 지연 관련 기능은 비활성화, 수정할 수 있다. 

### 2.5 TCP 느린 시작 (slow start)

- 보낼 수 있는 크기를 윈도우 크기로 제한
  - min(수신 윈도우 크기(버퍼 여유 용량), 혼잡 윈도우 크기)

- 급작스러운 부하, 혼잡을 방지하기 위해 TCP는 한번 전송할 수 있는 패킷의 수를 제한한다.
- 1부터 시작해서 **패킷 전송이 성공하면 2배씩 늘려가며 전송 양을 조절**한다. (slow start)
- 혼잡 제어 기능으로 인해, **새로운 커넥션은 이미 어느정도 데이터를 주고받은 튜닝된 커넥션보다 느리다.** 
  - 패킷 전송 수 1개인거보다 이미 2^n배로 늘어난게 더 많이 전송할 수 있음. 
- 따라서 HTTP에 **존재하는 커넥션을 재사용**하는 기능이 있다. 

### 2.6 네이글 알고리즘과 TCP_NODELAY

- 실리 윈도우 증후군(Silly window syndrome) : 1바이트 데이터를 위해 40바이트 헤더를 붙여 패킷을 전송하게 되는 것. 많은 패킷을 전송한다면 네트워크 성능은 떨어질 것
- **네이글 알고리즘(Nagle Algorithm)** 
  - 전송 속도는 떨어지지만 패킷을 줄여서 효율성을 증가시킴
  - 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한개의 덩어리로 합친다.
  - 세그먼트의 최대 크기가 되지 않으면 전송을 하지 않는다. 
  - 확인응답이 오면 최대 크기보다 작더라도 패킷 전송을 허용한다.
  - 즉 **패킷이 확인응답을 받았거나, 전송하기 충분할 만큼 패킷이 쌓였을 때 데이터가 전송된다.** 
- **문제**
  - 크기가 작은 HTTP 메시지는 패킷의 최대크기를 채우기 어렵다 -> 추가 데이터를 기다리며 지연됨
  - 네이글 알고리즘 + 확인응답 지연 -> 네이글 알고리즘은 확인응답을 기다리고있고, 확인응답은 보내기 전에 지연된다.
- `TCP_NODELAY` **파라미터를 설정하여 네이글 알고리즘을 비활성화할 수 있다.** 단 데이터 덩어리를 좀 크게 만들어야한다. 
  - 성능 최적화 할때 느려지는거같으면 이 옵션을 끄면 됨

### 2.7 TIME_WAIT의 누적과 포트 고갈

- TIME_WAIT 사용하는 이유
  - TCP 커넥션을 끊어도 같**은 주소와 같은 포트번호를 사용하는 새로운 TCP 커넥션이 일정 시간 동안에는 생성되지 않게** 기록한다. (2MSL - 약 2분정도) 
  - **이전 커넥션과 관련된 패킷이 새로운 커넥션에 삽입되는 문제를 방지한다.**
- 성능 시험(성능 벤치마크)시 문제
  - 성능 측정시 포트번호, IP주소 개수를 제한하고 짧은 시간내에 부하를 발생시키다보면 가능한 IP-Port 조합이 제한된다. 
  - TIME_WAIT으로 포트 재활용이 불가능해져 성능 측정시 사용할 포트가 고갈될 수 있다. 
  - 해결) 커널에 TW_REUSE=1 (default=0) 로 바꿔주면 타임웨잇되어있는 소켓 재사용 가능해짐 
  - -> 티켓팅서버같이 한번에 싹 몰릴 때, docker 컨테이너 default=0인데 이거 바꿔주지않으면 포트 고갈돼서 서버 문제남 

## 3. HTTP 커넥션 관리

HTTP 커넥션 관리에 있어 중요한 부분인 Connection 헤더와 HTTP 커넥션의 최적화 기술 

### 3.1 Connection 헤더 

**-> hop by hop이 주 내용** 

- Connection : HTTP 헤더 필드명, 임시 토큰 값, close
  - 필드명 : 이 커넥션에만 해당되는 헤더 나열
  - 임시 토큰 값 : 커넥션에 대한 비표준 옵션
  - close : 커넥션이 작업이 완료되면 종료되야함
- 커넥션 토큰이 HTTP 헤더 필드명을 가지고 있으면 해당 필드는 현재 커넥션만을 위한 정보이므로 다음 커넥션에 전달하면 안된다. 
- Connection 헤더는 **홉별(hop-by-hop)** 헤더 명을 기술한다. 
- 애플리케이션이 Connection 헤더와 함께 메시지를 전달 받으면 수신자는 송신자에게 온 요청에 기술된 모든 옵션을 적용하고 다음 홉에 메시지를 전달하기 전에 Connection 헤더와 헤더에 기술된 모든 헤더를 삭제한다. 

### 3.2 순차적 트랜잭션 처리에 의한 지연

- 예시 
  - 3개의 이미지가 있는 웹페이지 -> HTML , 이미지3개를 위해 총 4개의 커넥션을 맺는다. 
  - 순차적인 처리로 인한 물리적인 지연 뿐 아니라 사용자가 느끼는 심리적인 지연

이를 향상시키기 위한 병렬 커넥션(여러개의 tcp커넥션을 통한 동시 요청), 지속 커넥션(tcp커네션 재활용), 파이프라인 커넥션(공유 tcp 커넥션), 다중 커네션이 있다. 

## 4. 병렬 커넥션

- HTTP는 클라이언트가 여러개의 커넥션을 맺음으로써 병렬처리 할 수 있게 한다. 
  - 4개의 이미지를 각 TCP 커넥션 상의 트랜직션을 통해 병렬로 내려받음 
- 동시에, 한번에, 빠르게 받을 수 있지만 클라이언트의 네트워크 대역폭이 좁다면 제한된 대역폭 내에서 병렬 커넥션의 성능상의 장점은 거의 없어진다. --> 요즘엔 거의 대역폭 문제는 없당 부족하면 늘리니깐..
- 또한 다수의 커넥션은 메모리를 많이 소모하며 성능 문제를 일으킨다.
  - 100명의 사용자가 병렬로 모두 100개의 커넥션을 맺으면 10000개의 커넥션이 된다.
  - **브라우저는 실제로 적은수(대부분 4개, 최근엔 6~8개)의 병렬 커넥션을 허용한다**

## 5. 지속 커넥션

```text
- 커넥션 맺는 시간 지연 절약
- 튜닝된 패킷 속도로 커넥션 이용 (재사용하면 slow start 새로 안하는데 커넥션 새로하면 slow start 다시 해야돼서 패킷전송 자체도 빠름)
```

- 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션

- HTTP 요청을 하기 시작한 애플리케이션은 또 서버에 요청하게 될 확률이 높다. 사이트 지역성(Site locality)
- 따라서 HTTP/1.1(HTTP/1.0 개선버전)을 지원한다면 TCP 커넥션을 유지하여 재사용할 수 있다. 
- 느린시작으로 인한 지연을 피한다. 

### 5.1 지속 커넥션 vs 병렬 커넥션

- 병렬 커넥션의 단점
  - 각 트랜잭션마다 새로운 커넥션을 맺는데 소모되는 시간과 대역폭
  - 새로운 커넥션은 모두 느린시작을 함(slow start)
  - 실제 연결할 수 있는 병렬 커넥션 수의 제한
- 지속 커넥션의 장점
  - 커넥션을 맺기 위한 사전 작업이 줄어들고, 튜닝(slow start이후 수차례 성공하여 패킷 전송 수가 많아진상태)된 커넥션을 유지하며 커넥션의 수가 줄어든다. 
- 단점 - 계속 연결된 상태로 있는 커넥션이 쌓이게 된다면 문제가 될 수 있다.
- **지속 커넥션과 병렬 커넥션을 함께 사용한다.**
  - 적은 수의 병렬 커넥션과 지속 커넥션 유지 

### 5.2 HTTP/1.0+ 의 Keep-Alive 커넥션

- 연속으로 4개의 커넥션을 생성하는 것이 아닌 하나의 지속커넥션만 이용하면서 커넥션 맺고 끊는데 필요한 작업 시간을 단축

### 5.3 Keep-Alive 동작

- <u>Keep-Alive는 HTTP/1.1명세에서 빠졌다.</u>
- Connection:Keep-Alive 헤더를 포함시키고, 계속 포함 시키다가 헤더를 제거하면 커넥션을 끊을 것을 추정한다.

### 5.4 Keep-Alive 옵션

- Keep-Alive 헤더는 커네션을 유지하기 위한 요청일 뿐 실제로 따를 필요는 없다. 
  - 단 사용은 Connection:Keep-Alive 헤더가 있을 때 만 사용할 수 있다. 
- timeout :Keep-Alive 응답 헤더를 통해 커넥션이 유지될 시간을 알려주지만 이것도 보장하지는 않는다.
- max : Kepp-Alive 응답 헤더를 통해 보내며 몇번의 트랜잭션을 처리할 때까지 유지될것인지 의미

### 5.5 Keep-Alive 커넥션 제한과 규칙

- HTTP/1.0에서 기본으로 사용되지 않고 헤더에 명시해줘야한다. 
- 커넥션이 끊어지기 전에 Content-Length로 본문의 길이를 항상 보내야한다. 이게 없다면 트랜잭션이 끝나는 시점과 새로운 메시지의 시작점을 정확히 알 수 없다.
- 프락시와 게이트웨이는 Connection헤더의 규칙을 철저히 지켜야한다. (다음 전달 전에 커넥션 관련 헤더 모두 지우는것)
- 클라이언트는 응답을 모두 받기 전에 커넥션이 끊어졌을 경우 요청을 다시 보낼 수 있게 준비되있어야한다. 

### 5.6 Keep-Alive와 멍청한 프락시

> 멍청한 프락시 부분은 책읽으면서 그냥 흐름을 이해하는게 나은 것 같아서 대충 이해한만큼만 썼음 
>
> 얘네 너무 옛날 내용이라 요즘 프록시들은 다 똑똑해서 이런 상황 별로 발생안한다고함..ㅎ

- Connection을 이해하지 못하는 프락시가 중간에 껴버렸을 경우 다음 hop으로 갈 때 Connection을 삭제하지 않고 그대로 보내 원 서버까지 Connection 헤더를 달고 간 후, 다시 클라이언트에게 Connection 헤더를 전달하며 커넥션이 유지될 것으로 연결을 맺는다.
- 하지만 **프락시는 Connection을 이해하지 못해 요청,응답 후에 커넥션을 끊을 것이고 그 후에 오는 요청은 처리하지 못하게 된다.** 
- 브라우저는 유지되는 커넥션에 요청을 보냈다고 생각하고 응답을 기다리게되고 **타임아웃이나 커넥션이 끊길 때 까지 기다리는 문제가 생긴다.** 
- 프락시는 Connection, Proxy-xx등의 헤더를 다음 hop에 절대 전달하면 안된다. 

### 5.7 Proxy-Connection

- 멍청한 프락시가 Connection을 이해하지 못할 문제를 해결하기 위해 영리한 프락시는 이해해서 Connection처리를 하고, 멍청한 프락시와 프락시가 아닌 서버는 이 헤더를 무시하도록 Proxy-XX 헤더를 사용한다. 

### 5.8 HTTP/1.1의 지속 커넥션

- HTTP/1.1은 Keep-alive 커넥션을 지원하지 않는 대신 **기본으로 지속 커넥션을 활성화했다** (프록시가 자꾸 못알아먹으니깐 걍 기본으로하고 안할때 close)
- 별도 설정을 하지 않은 모든 커네션을 지속 커넥션으로 취급한다.
- 다음 커넥션을 끊으려면 `Connection:close`헤더를 명시한다. 
  - 이것이 없다고 서버가 커넥션을 영원히 유지하겠다는 의미는 아니다. 

### 5.9 지속 커넥션의 제한과 규칙

- 클라이언트가 요청에 Connection:close를 포함했으면 클라이언트는 이후에 추가적인 요청을 보낼 수 없다. 
- 커넥션에 있는 모든 메시지가 자신의 길이 정보를 정확히 가지고 있어야만 커넥션을 지속시킬 수 있다. `Content-Length`, 또는 청크 전송 인코딩이 있어야 한다.
  - 커넥션 사이사이 메시지를 구분해야하므로 
- 프락시는 클라이언트와 서버사이 각각 별도의 지속 커넥션을 맺고 관리해야한다. 
- HTTP/1.1기기는 헤더 값과 상관없이 언제든 커넥션을 끊을 수 있고, 중간에 끊어지는 커넥션을 복구하고 다시 요청을 보낼 준비를 하고 있어야한다. 
- 서버과부하 방지를 위해 넉넉잡아 두개정도의 지속 커넥션만을 유지해야한다.  

## 6. 파이프라인 커넥션

- **지속커넥션을 통한** 파이프라이닝

- 여러개의 요청이 응답이 도착하기 전까지 **큐에 쌓여** 전송 대기시간을 줄여주는 방법

- 주의

  - HTTP응답은 요청 순서와 같게 와야한다.
  - 클라이언트는 커넥션이 끊어지더라도 완료되지 않은 요청이 있다면 언제든 다시 보낼 준비를 하고 있어야한다.
  - POST같이 여러번 보냈을 때 문제가 생기는 경우 파이프라인을 통해 보내면 안된다. (비멱등)
  - **멱등성을 가지게 보내야한다.**

  

## 7. 커넥션 끊기

언제든 마음대로 커넥션을 끊을 수 있다. 보통 메시지를 다 보내고 끊지만 에러가 있는 상황에서는 끊길 수 있다. 

### 7.2 Content-Length 와 Truncation

- 각 응답은 본문의 정확한 크기 값을 가지는 Content-length헤더를 가지고 있어야 한다. 
- 커넥션이 끊어졌다는 응답을 받은 후 실제 전달된 엔티티의 길이와 Content-Length를 비교해 일치하지 않으면 다시 확인해야한다.

### 7.3 재시도, 멱등성

- 커넥션은 에러가 없더라도 언제든 끊을 수 있으므로 적절히 대응할 수 있는 준비가 되어이써야 한다.
- 단 재시도할 때 POST 요청을 반복해서 보내는 것은 주의해야한다.
- **멱등**: **한번 혹은 여러번 실행됐는지에 상관 없이 같은 결과를 반환한다면 그 트랜잭션은 멱등이라한다.**
  - GET, HEAD, PUT, DELETE, TRACE, OPTION
  - POST는 멱등이 아니다. 이때 다시 보내려고한다면 응답을 받을 때 까지 기다리거나, 다시 묻는 대화상자를 띄워야한다. 

### 7.4 우아한 커넥션 끊기

- TCP 커넥션은 양방향이다. 커넥션 양쪽에 데이터 입력/출력 큐가 각각 있다.

**전체 끊기와 절반 끊기 - close(), shutdown()**

- `close()`를 호출하면 TCP 커넥션의 입력채널과 출력채널의 커넥션을 모두 끊는다. 
  - 주체적으로 끊는 쪽이 active close(FIN_WAIT) 받는쪽이 passive close(CLOSE_WAIT)
  - active close 상태 : FIN_WAIT1 -> passive close에서 fin보내면 FIN_WAIT2 -> 2MSL 기다렸다가 (TIME_WAIT) close 
- 채널 하나만 개별적으로 끊으려면 `shutdown()` 을 호출하면 된다. 

**TCP 끊기와 리셋 에러**

- 애플리케이션이 각기 다른 HTTP 서버,클라이언트,프록시와 통신할 때, 그들과 파이프라인 지속 커넥션을 사용한다면 예상치 못한 쓰기 에러 방지를 위해 절반끊기를 사용해야한다. 
- 보통은 출력 채널을 끊고, 반대편에 있는 기기는 버퍼로부터 모든 데이터를 읽고나서 커넥션이 끊어졌음을 알게 될것이다. 
- 클라이언트가 더 데이터를 보내지 않을 것을 확신할 수 없는 이상 입력채널을 끊는것은 위험하다. 
  - 이미 끊긴 입력 채널에 데이터를 전송하면 버퍼에 있는 모든 데이터를 삭제하게될 수 있다. 

**우아하게 커넥션 끊기**

- 일반적으로 자신의 출력 채널을 먼저 끊고 다른 쪽의 출력 채널이 끊기는 것을 기다리는 것 
- 양쪽에서 더는 데이터를 전송하지 않을 것을 알려주면 온전히 종료된다. 

