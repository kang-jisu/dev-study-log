리뷰:
> 오브젝트책을 읽고있었는데(멈춘지 몇개월..) 이 책이 오브젝트의 서론이 되는 부분에 대한 설명이라고해서 읽어봤다. 회사에 있길래 시간이 없어서 약 이틀 걸려서 진짜 속독했다.
> 사실 다 이해했다거나 뭔가 제대로 봤다고는 할 수 없지만 이 책에서 하려고하는 내용이 무엇인지 겉핥기라도 알고싶어서 빨리 읽었다.
> 객체지향이라는 개념에 대해서 다가갈 때 그냥 무작정 클래스를 만들고 함수를 나누고,,가 아니고 책임과 역할, 각 객체사이의 협력,연관,포함관계들을 생각하고 메세지가 전달되는 방식에따른 설계를 하는것에 대해서 조금이라도 내가 느꼈길 바란다 ..
> 지금은 웹개발로 그냥 무작정 CRUD만 하고있는데 이런 객체지향적인 설계를 위한 ..그 계산기,로또,이런거 구현  하는거같은 주제로 코드짜는 연습을 한번 해봐야겠다.
> 이번엔 스르륵 훑는게 목표였으니 오브젝트나,, 뭐 더 읽고나서 꼭 한번 더 읽어보기!

# 커피전문점 도메인
## 커피 주문
예제의 목적은 커피 전문점에서 커피를 주문하는 과정을 객체들의 협력관계로 구분하는 것이다.


예제
- 커피전문점에서는 아메리카노, 카푸치노, 카라멜 마키아또, 에스프레소 네가지 커피 판매
  - 아메리카노 : 1500원
  - 카푸치노 : 2000원
  - 카라멜 마키아또 : 2500원
  - 에스프레소 : 2500원
- 손님이 커피를 주문한다.
- 주문받은 커피를 제조하는 것은 바리스타의 몫이다.
- 손님이 커피를 주문하는 사건을 컴퓨터 안에 재구성하는 것이 목표이다.



**커피전문점 도메인**
- 손님 객체
  - 손님은 메뉴판에서 커피를 선택할 수 있다.
  - 손님은 바리스타에게 커피를 주문한다
- 메뉴 항목 객체
  - 아메리카노 : 1500원
  - 카푸치노 : 2000원
  - 카라멜 마키아또 : 2500원
  - 에스프레소 : 2500원
- 메뉴판 객체
  - 메뉴 항목 객체들을 가진다.
- 바리스타 객체
  - 커피를 제조한다.
- 커피 객체
  - 아메리카노 객체
  - 카라멜 마키아또 객체
  - 에스프레소 객체
  - 카푸치노 객체

**관계 설정**
- 손님 객체
  - **손님은 메뉴판에서 커피를 선택할 수 있다. : 손님-메뉴판 관계**
  - **손님은 바리스타에게 커피를 주문한다. : 손님 - 바리스타 관계**
- 메뉴 항목 객체
  - 아메리카노 : 1500원
  - 카푸치노 : 2000원
  - 카라멜 마키아또 : 2500원
  - 에스프레소 : 2500원
- 메뉴판 객체
  - 메뉴 항목 객체들을 가진다.
- 바리스타 객체
  - **커피를 제조한다. : 바리스타 - 커피 관계**
- 커피 객체
  - 아메리카노 객체
  - 카라멜 마키아또 객체
  - 에스프레소 객체
  - 카푸치노 객체

**인스턴스**
- 손님 객체 : **손님타입의 인스턴스**
  - 손님은 메뉴판에서 커피를 선택할 수 있다. : 손님-메뉴판 관계
  - 손님은 바리스타에게 커피를 주문한다. : 손님 - 바리스타 관계
- 메뉴 항목 객체 **메뉴 항목 타입의 인스턴스**
  - 아메리카노 : 1500원
  - 카푸치노 : 2000원
  - 카라멜 마키아또 : 2500원
  - 에스프레소 : 2500원
- 메뉴판 객체 : **메뉴판 타입의 인스턴스**
  - 메뉴 항목 객체들을 가진다.
- 바리스타 객체 : **바리스타 타입의 인스턴스**
  - 커피를 제조한다. : 바리스타 - 커피 관계
- 커피 객체 : **커피타입의 인스턴스**
  - 아메리카노 객체
  - 카라멜 마키아또 객체
  - 에스프레소 객체
  - 카푸치노 객체

**세부 관계(포함, 합성, 연관)**
> 이때 관계가 포함이고 연관이고는 사실 중요하지 않다. 그냥 도메인을 이해하는 것이다. 서로 관계가 있다는걸 이해하는 것만으로도 충분하다.   
1. 하나의 메뉴판객체는 다수의 메뉴 항목 객체로 구성되어있다.
메뉴항목 객체는 메뉴판 객체에 포함된다.
`메뉴판`<>------4`메뉴항목`  : 포함


2. 손님 타입은 메뉴판 타입을 알고 있어야 원하는 커피를 선택할 수 있다.   
인스턴스가 다른 타입의 인스턴스를 포함하지는 않지만 서로 알고있어야 하는 경우 연관관계라고 한다.  
`메뉴판`-----`손님` : 연관  

3. 바리스타 타입은 커피를 제조해야 하므로 커피 타입을 알고있어야 한다.
`바리스타` ----- `커피` : 연관

![이밎지](https://techblog.woowahan.com/wp-content/uploads/img/2016-07-07/7_5.png)

<br/>


## 설계하고 구현하기
### 커피를 주문하기 위한 협력 찾기
> 훌륭한 객체를 설계하는 것이 아니라, 훌륭한 협력을 설계해야한다.
> 메세지가 객체를 선택하도록 해야한다.
> - 즉 **메세지를 선택**하고 **메세지를 수신하기에 적절한 객체를 선택**해야한다.
> - 즉 메세지를 수신할 객체는 메세지를 처리할 책임을 맡게 되고 객체가 수신하는 메세지는 객체가 외부에 제공하는 공용 인터페이스 포함된다.

```bash
1. 메세지 선택
2. 책임을 수행하기에 적절한 객체 선택
3. 인스턴스화
```

- 커피를 주문해라 with 메뉴 이름
  - **손님** 타입의 인스턴스가 메세지를 처리할 객체이다.
  - **손님이 스스로 할수 없는 일이 있다면 다른 객체에게 요청해야한다.**
    - 이것이 외부로 전송되는 메세지
  - 손님은 외부 항목에 대해서 알지 못한다.
  - 고객은 메뉴 항목을 누군가가 요청해 줄것을 요청한다.

- 메뉴 항목을 찾아라 with 메뉴 이름 : return 메뉴 항목
  - 메뉴 항목을 찾을 책임은 **메뉴판** 객체
    - 객체지향에서는 수동적인 메뉴판이라는 사물도 능동적으로 자신의 메뉴를 찾게된다. 객체지향이 현실 속 객체를 추상화, 모방한것이 아니라 그 행동,의미 유추할 수 있게 은유한다는 것을 잊지말자.

- 메뉴 항목에 맞는 커피를 제조해달라 with 메뉴 항목 return 커피
  - 바리스타객체
  - 바리스타 객체가 어떻게 커피를 제조할지는 바리스타의 지식(상태)와 기술(행동)이다.

- 커피를 생성하라
  - 커피

<br/>

## 인터페이스 정리하기
**객체가 수신한 메세지가 객체의 인터페이스를 결정한다**는 사실을 기억하라.
객체가 어떤 메세지를 수신할 수 있다는 것은 그 객체의 인터페이스 안에 메세지에 해당하는 오퍼레이션이 존재한다는 것을 의미한다.

- 손님 객체의 인터페이스 안에는 '커피를 주문하라' 라는 오퍼레이션이 포함돼야 한다.`void 커피를 주문하라(메뉴이름)`
- 메뉴판 객체의 인터페이스에는 '메뉴 항목을 찾아라' 라는 오퍼레이션을 제공 `메뉴항목 메뉴항목을 찾아라(메뉴 이름)`
- 바리스타 객체는 '커피를 제조하라' `커피 커피를 제조하라(메뉴항목)`
- 커피 객체는 '생성하라' `void 생성하라(커피)`


## 코드
```java
public class Barista {
    
    public Coffee makeCoffe(MenuItem menuItem) {
        Coffee coffee = new Coffee(menuItem);
        return coffee;
    }
}

```

```java
public class Coffee {

    String name;
    private int price;
    public Coffee(MenuItem menuItem) {
        this.name = menuItem.getName();
        this.price = menuItem.cost();
    }
}


```

```java
public class Customer {

    // 고객은 메뉴판에게 메뉴이름을 가지고 메뉴 조회를 요청한다.
    // 고객은 바리스타에게 커피 주문을 한다.

    public void order(String menuName, Menu menu, Barista barista) {
        MenuItem menuItem = menu.choose(menuName);
        Coffee coffee = barista.makeCoffe(menuItem);
    }
}


```

```java
public class Menu {

    private List<MenuItem> items;

    public Menu(List<MenuItem> items) {
        this.items = items;
    }

    public MenuItem choose(String name) {
        for( MenuItem each : items) {
            if(each.getName().equals(name)){
                return each;
            }
        }
        return null;
    }
}


```

```java
public class MenuItem {

    private String name;
    private int price;

    public MenuItem(String name, int price) {
        this.name = name;
        this.price = price;
    }
    public String getName() {
        return this.name;
    }

    public int cost() {
        return price;
    }
}


```


-  출처
   - 같은 내용 정리된글 이미지 참고 https://techblog.woowahan.com/2502/
   - 원본책 : 객체지향의 사실과 오해