## [ITEM 49] 매개변수가 유효한지 검사하라

```
메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. 
- 인덱스 값은 음수이면 안된다.
- 객체 참조는 null이 아니어야 한다.

이런 제약은 반드시 문서화해야하며 메서드 몸체가 시작되기 전에 검사해야한다.
```



메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다. 만약 매개변수 검사를 제대로 하지 못하면 몇가지 문제가 생길 수 있다.

- 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
- 메서드가 잘 수행되지만 잘못된 결과를 반환할 수 있다. `더 나쁜 상황`
- 메서드는 문제없이 수행됐지만 어떤 객체를 이상한 상태로 만들어놓아서 미래의 알 수 없는 시점에 이 메서드와는 관련없는 오류를 낼 수 있다. `최악의 상황`

=> 매개변수 검사에 실패하면 **실패 원자성**을 어기는 결과를 낳을 수 있다.  

**public과 protected메서드는 매개변수 값이 잘못 됐을 때 던지는 예외를 문서화해야한다.**

> @throws 자바독 태그 사용  
>
> 보통 IllegalArgumentException, IndexOutOfBoundsException, NullPointerException중 하나가 될 것 

```java
/**
* (현재 값 Mod m) 값을 반환한다. 이 메서드는
* 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다.
* @param m 계수 (양수)
* @return 현재 값 mod m
* @throws ArithmeticException m이 0보다 작거나 같으면 발생한다. 
*/
public BigInteger mod(BigInteger m) {
  if(m.signum() <= 0) {
    throw new ArithmeticException("계수(m)은 양수여야 합니다. "+m);
    //...
  }
}
```

- 이 때 m이 null일때 `NullPointerException`을 던진다는 설명이 없는 이유는 설명을 BigInteger클래스 수준에서 기술했기 때문이다.
  - 클래스 수준 주석은 그 클래스의 모든 public 메서드에 적용되므로 각 메서드에 일일이 기술하는 것 보다 훨씬 깔끔하다.
- 자바7에 추가된 **java.util.Objects.requireNonNull** 메서드는 유연하고 사용하기 편하니 null 검사를 수동으로 하지 않아도 된다.   



Java9의 범위검사, assert검사 부분 생략

<br/>

### 생성자의 매개변수 유효성 검사

메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경써서 검사해야한다. 

```java
static List<Integer> intArrayAsList(int[] a) {
  Objects.requireNonNull(a);
  
  return new AbstractList<>() {
    // ...
  }
}
```

예로 입력받은 int배열의 List뷰를 반환하는 메서드에서 null검사를 수행하지 않았다면 새로 생성한 List인스턴스를 반환할 때 클라이언트가 돌려받은 List를 사용하려할 때 비로소 NullPointerException이 발생한다. 이 때가 되면 이 List를 어디서 가져왔는지 추적하기 어려워 디버깅이 상당히 괴로워질 수 있다.   



**생성자는 나중에 쓰려고 저장하는 매개변수의 유혀성을 검사하라는 원칙의 특수한 사례이다.**  
생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게하는데 꼭 필요하다.    



**예외**  
유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때, 혹은 계산 과정에서 암묵적으로 검사가 수행될 때는 예외이다.  

- 예
  - Collections.sort(List)처럼 객체를 정렬할 때 비교될 수 없는 타입의 객체가 들어있다면 ClassCastException이 발생될 것이다. 
  - 비교하기에 앞서 타입검사를 해봐야 별다른 실익이 없다.  

하지만 암묵적 유효성 검사에 너무 의존했다가는 실패원자성을 해칠 수 있으니 주의해야한다. 



**API문서의 예외와 다른 예외를 던지는 경우**  
계산과정에서 필요한 유효성 검사가 이루어져 실패했을 때 API문서에 명세한 예외와 다른 예외를 던질 수도 있다. 이때는 API문서에 기재된 예외로 번역해주어야 한다.  



### 정리

```
메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을 지 생각해야한다. 그 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야한다. 이런 습관을 반드시 기르도록 하자. 그 노력은 유효성 검사가 실제 오류를 처음 걸러낼 때 충분히 보상받을 것이다. 
```

