읽으면서 밑줄 그은 부분들 한번 더 적어보기





# 1장 안정성

크래시가 적으면 사용자와 개발자 모두에게 좋고, 상당한 비즈니스 가치를 제공합니다.

이번 장에서 다루는 내용의 기본적인 목적은 '오류가 덜 발생하는 코드를 만드는 것' 입니다.





### Item1. 가변성을 제한하라

p.5

- 가변성이 있으면 시점에 따라서 값이 달라질 수 있으므로, 현재 어떤 값을 갖고 있는지 알아야 코드의 실행을 예측할 수 있다. 한 시점에 확인한 값이 계속 동일하게 유지된다고 확신할 수 없다.

멀티스레드 - 적절한 동기화 필요

- 모든 상태를 테스트해야 하므로 테스트하기 어려움

p.6

- 변할 수 있는 지점은 줄일수록 좋다.

p.7

- 코틀린에서 가변성 제한하기
  - 읽기 전용 프로퍼티(val)
  - 가변 컬렉션과 읽기 전용 컬렉션 구분
  - 데이터 클래스의 copy

p.8

- var 프로퍼티를 사용하는 val 프로퍼티는 var 프로퍼티가 변할 때 변할 수 있다.

p.10

- val은 읽기 전용 프로퍼티지만, 변경할 수 없음을 의미하는 것은 아니다. 완전히 변경할 필요가 없다면 final 프로퍼티를 사용하는 것이 좋다. 

p.12

- 리스트를 읽기 전용으로 릴턴하면 이를 읽기 전용으로만 사용해야 한다. 이는 단순한 계약의 문제라고 할 수 있다.
- 컬렉션 다운캐스팅은 이러한 계약을 위반하고, 추상화를 무시하는 행위이다.

p.13

- 읽기 전용에서 mutable로 변경해야 한다면, 복제(copy)를 통해서 새로운 mutable 컬렉션을 만드는 list.toMutableList를 활용해야 한다.

p.14

- mutable객체는 set, map의 키로 사용할 수 없다. 내부적으로 해시 테이블을 사용하고, 해시 테이블은 처음 요소를 넣을 때 요소의 값을 기반으로 버킷을 결정하기 때문
- 따라서 immutable 객체는 자신의 일부를 수정한 새로운 객체를 만들어 내는 메서드를 가져야 한다.

p.19

- 방어적 복제(defensive copying) 
- 가능하다면 무조건 가변성을 제한하는 것이 좋다.
- 컬레션은 객체를 읽기 전용 슈퍼타입으로 업캐스트하여 가변성을 제한할 수도 있다.

p.20

- 추가로 Immutable 객체를 사용할 때는 언제나 멀티스레드 때에 더 많은 주의를 기울여야 한다는 것을 기억하라. 



### item2. 변수의 스코프를 최소화하라

p.21

- 최대한 좁은 스코프를 갖게 변수를 사용한다. 

p.22

- 변수는 읽기 전용 또는 읽고 쓰기 전용 여부와 상관 없이, 변수를 정의할 때 초기화되는 것이 좋다.

p.23

- 여러 프로퍼티를 한꺼번에 설정해야 하는 경우에 구조분해 선언(destructuring declaration) 활용



### Item3. 최대한 플랫폼 타입을 사용하지 말라

p.27

- nullable과 관련하여 자주 문제가 되는 부분은 바로 자바의 제네릭 타입이다.

p.33

- 다른 프로그래밍 언어에서 와서 nullable 여부를 알 수 없는 타입을 플랫폼 타입이라고 부른다.
- 이런 코드를 사용하고 있다면 빨리 해당 코드를 제거하는 것이 좋다.



### Item4. Inferred 타입으로 리턴하지 말라

### Item5. 예외를 활용해 코드에 제한을 걸어라

p.37

- require: 아규먼트 제한
- cehck : 상태와 관련된 동작 제한
- assert: 어떤 것이 true인지 확인, 테스트 모드에서만 작동
- return 또는 throw와 함께 활용하는 Elvis 연산자

p.39

- require - 람다를 활용해서 지연 메시지를 정의할 수도 있다. 

p.42

- assert - 특정 상황이 아닌 모든 상황에 대한 테스트를 할 수 있다.
- 표준 애플리케이션 실행에서는 assert가 예외를 throw하지 않는다는 것도 기억



### Item6. 사용자 정의 오류보다는 표준 오류를 사용하라

p.46

- 가능하다면, 직접 오류를 정의하는 것보다는 최대한 표준 라이브러리 오류를 사용하는 것이 좋다.
- 표준 라이브러리의 오류는 많은 개발자가 알고 있으므로, 이를 재사용하는 것이 좋다.



### Item7. 결과 부족이 발생할 경우 null과 Failure를 사용하라

p.48

- null또는 실패를 나타내는 seald 클래스 (=Failure) 리턴
- 예외를 throw
- 예외는 정보를 전달하는 방법으로 사용해서는 안 된다.
- 예외는 예외적인 상황이 발생했을 때 사용하는 것이 좋다.

p.50

- null과 sealed result 클래스는 명시적으로 처리해야 하며, 애플리케이션의 흐름을 중지하지도 않는다.
- Failure는 처리할 때 필요한 정보를 가질 수 있다.

p.51

- 개발자에게 null이 발생할 수 있다는 경고를 주려면, getOrNull 등을 사용해서 무엇이 리턴되는지 예측할 수 있게 하는 것이 좋다.



### Item8. 적절하게 null을 처리하라

p.52

- null은 최대한 명확한 의미를 갖는 것이 좋다.
- ?., 스마트 캐스팅, Elvis 연산자 등을 활용해서 안전하게 처리한다.
- 오류를 throw 한다
- 함수 또는 프로퍼티를 리팩토링해서 nullable 타입이 나오지 않게 바꾼다.

p.53

- 스마트 캐스팅은 코틀린의 규약 기능(contrancts feature)을 지원한다.

p.55

- 그런데 !!를 사용하면 자바에서 nullable을 처리할 때 발생할 수 있는 문제가 똑같이 발생한다. 어떤 대상이 null이 아니라고 생각하고 다루면, NPE 예외가 발생한다.
- !!은 어떤 설명도 없는 제네릭 예외가 발생한다.
- 현재 확실하다고 미래에 확실한 것은 아니다.

p.57

- 일반적으로 !! 연산자 사용을 피해야 한다.

p.58

- 어떤 값이 클래스 생성 이후에 확실하게 설정된다는 보장이 있다면, lateinit 프로퍼티와 notNull 델리게이트를 사용하라.
- 요소가 부족하다는 것을 나타내려면 빈 컬렉션을 사용하라

p.59

- lateinit 한정자는 프로퍼티가 이후에 설정될 것임을 명시하는 한정자이다.

p.60

- 기본 타입과 연결된 타입으로 프로퍼티를 초기화해야 하는 경우 Delegates.notNull을 사용한다.



### Item9. use를 사용하여 리소스를 닫아라

p.62

- close 메서드를 사용해서 명시적으로 닫아야 하는 리소스
- AutoCloseable을 상속받는 Closeable 인터페이스를 구현(implement)하고 있다.

p.63

- 그래도 굉장히 많이 사용되는 일반적인 구현이므로, 표준 라이브러리에 use라는 이름의 함수로 포함되어 있다.

p.64

- use를 사용하면 Closeable/AutoCloseable을 구현한 객체를 쉽고 안전하게 처리할 수 있다.
- 파일을 처리할 때는 파일을 한 줄씩 읽어 들이는 useLines를 사용하는 것이 좋다.



### Item10. 단위 테스트를 만들어라

p. 66

- 일반적인 유스케이스(happy path)
- 오류 케이스, 잠재적인 문제
- 엣지케이스
- 테스트가 잘 된 요소는 신뢰할 수 있다.
- 테스트가 잘 만들어져 있따면 리팩터링하는 것이 두렵지 않다.

p.67

- 단점1. 단위 테스트를 만드는 데 시간이 걸린다.
- 단점2. 테스트를 활용할 수 있게 코드를 조정해야 한다.
- 단점3. 잘못 만들어진 단위 테스트는 득보다 실이 크다.

p.68

- 복잡한 부분
- 계속해서 수정이 일어나고 리팩터링이 일어날 수 있는 부분
- 비즈니스 로직 부분
- 공용 API 부분
- 문제가 자주 발생하는 부분
- 수정해야 하는 프로덕션 버그





