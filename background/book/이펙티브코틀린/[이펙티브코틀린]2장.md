# 2장. 가독성

코틀린은 간결성을 목표로 설계된 프로그래밍 언어가 아니라, 가독성을 좋게 하는 데 목표를 두고 설계된 프로그래밍 언어이다.

코틀린은 우리가 원하는 것을 숨기거나 강조할 수 있게 하는 기능을 많이 제공한다.



### Item11. 가독성을 목표로 설게하라

p.71

- 개발자는 어떤 코드를 작성하는 것보다 읽는 데 많은 시간을 소모한다.

p.72

- 하지만 숙련된 개발자만을 위한 코드는 좋은 코드가 아니다. 구현 A(if문) 와 구현B(let, elvis)는 사실 비교조차 할 수 없을정도로 A가 훨씬 가독성이 좋은 코드이다.
- 구현 A는 수정하기 쉽다.

p.73

- 익숙하지 않은 구조를 사용하면, 이처럼 잘못된 동작을 코드를 보면서 확인하기 어렵다.
- 기본적으로 '인지 부하'를 줄이는 방향으로 코드를 작성하라.

p.74

- nullable 가변 프로퍼티가 있고 null이 아닐 때만 어떤 작업을 수행해야 하는 경우 let을 사용하는 것도 좋다. (let을 아예 사용하지 말라는 것이 아님)
- 가변 프로퍼티는 쓰레드와 관련된 문제를 발생시킬 수 있으므로, 스마트 캐스팅이 불가능하다.
- let - 연산을 아규먼트 처리 후로 이동시킬 때
- let - 데코레이터를 사용해서 객체를 랩할 때

p.75

- 문제가 되는 경우는 비용을 지불할 만한 가치가 없는 코드에 비용을 지불하는 경우이다.
- 균형을 맞추는 것이 중요하다.
- 또한 두 구조를 조합해서 사용하면, 단순하게 개별적인 복잡성의 합보다 훨씬 커진다는 것을 기억하라.

p.76

- 연산자는 의미에 맞게 사용한다.
- 함수 이름이 실제 함수 내부에서 이루어지는 처리와 맞지 않다.
- 이미 있는 것을 다시 만들 필요는 없다.





### Item 12. 연산자 오버로드를 할 때는 의미에 맞게 사용하라

p.79

- 자유는 많은 개발자가 해당 기능을 오용하게 만듭니다.
- 연산자가 일반적인 의미로 사용되지 않고 있다면, 연산자를 볼 때마다 연산자를 개별적으로 이해해야 하기 때문에 코드를 이해하기 어려울 것입니다.

p. 80

- 의미가 명확하지 않다면, infix를 활용한 확장 함수를 사용하는 것이 좋습니다.



### Item 13. Unit?을 리턴하지 말라

### Item 14. 변수 타입이 명확하지 않은 경우 확실하게 지정하라

p.84

- 코드 정의로 쉽게 이동할 수 없는 깃허브 등의 환경에서 코드를 읽을 수도 있습니다.

### Item 15. 리시버를 명시적으로 참조하라

p.89

- 리시버가 명확하지 않다면, 명시적으로 리시버를 적어서 이를 명확하게 하라.
- 레이블 없이 리시버를 사용하면, 가장 가까운 리시버를 의미한다.
- 외부에 있는 리시버를 사용하려면, 레이블을 사용해야 한다.

p.91

- 짧게 적을 수 있다는 이유만으로 리시버를 제거하지 말라.
- 여러개의 리시버가 있는 상황 등에는 리시버를 명시적으로 적어 주는 것이 좋다.
- DSL에서는 DslMarker 메타 어노테이션을 사용할 수도 있다. (외부 리시버 금지 강제)



### Item 16. 프로퍼티는 동작이 아니라 상태를 나타내야 한다.

p.92

- field라는 식별자
- val을 사용해서 읽기 전용 프로퍼티를 만들 때ㅑ는 field가 만들어지지 않는다.

p.94

- 프로퍼티를 함수 대신 사용할 수도 있지만, 그렇다고 완전히 대체해서 사용하는 것은 좋지 않다. 예를 들어 프로퍼티로 다음과 같이 알고리즘의 동작을 나타내는 것은 좋지 않다.

p.95

- 원칙적으로 프로퍼티는 상태를 나타내거나 설정하기 위한 목적으로만 사용하는 것이 좋다.
- '이 프로퍼티를 함수로 정의할 경우, 접두사로 get 또는 set을 붙일 것인가?' 만약 아니라면 이를 프로퍼티로 만드는 것은 좋지 않다.
- 연산 비용이 높거나, 복잡도가 O(1)보다 큰 경우
- 비즈니스 로직(애플리케이션 동작)을 포함하는 경우
- 결정적적으로 않은 경우(같은 동작을 연속적으로 두 번 했는데 다른 값이 나올 수 있다면)
- 변환의 경우
- 게터에서 프로퍼티의 상태 변경이 일어나야 하는 경우



### Item17. 이름 있는 아규먼트를 사용하라

p.97 

- named arguement

p.98

- 이름 있는 아규먼트를 사용하면 코드가 길어지지만, 다음과 같은 두 가지 장점이 생깁니다.
  - 이름을 기반으로 값이 무엇을 나타내는지 알 수 있습니다.
  - 파라미터 입력 순서와 상관 없으므로 안전합니다.

p.98

- 디폴트 아규먼트
- 같은 타입의 파라미터가 많은 경우
- 함수 타입의 파라미터가 있는 경우(마지막 경우 제외)



### ITEM 18. 코딩 컨벤션을 지켜라





