## 3장 . 재사용성



### ITEM19. knowledge를 반복하여 사용하지 말라

p.111

- 의도적인 정보를 나타내는 개념이므로, 이 책에서는 knowledge를 원어 그대로 사용

p.112

- 비즈니스 로직은 시간이 지나면서 계속해서 변하지만, 공통 알고리즘은 한 번 정의된 이후에는 크게 변하지 않습니다.

p. 113

- 모든 것은 변화하고, 우리는 이에 대비해야 한다. 변화할 때 가장 큰 적은 knowledge가 반복되어 있는 부분이다. 

p.115

- 두 코드가 같은 knowedge를 나타내는지, 다른 knowledge를 나타내는지는 "함께 변경될 가능성이 높은가? 따로 변경될 가능성이 높은가?"라는 질문으로 어느 정도 결정할 수 있다.

p.117

- 아마 개발자는 해당 함수가 활용되고 있는 다른 부분도 확인했을 것이다.하지만 이 함수가 자신이 해야 하는 일 이외의 책임을 갖고 있을 거라는 것은 예측하지 못한 것이다.
- 두 함수는 Student 클래스 아래에 두면서도, 각각의 부서가 관리하는 서로 다른 모듈 파일에 배치할 수도 있을 것이다.

p.118

- 서로 다른 곳(위의 예에서는 서로 다른 부서)에서 사용하는 knowledge는 독립적으로 변경할 가능성이 많다. 따라서 비슷한 처리를 하더라도, 완전히 다른 knowledge로 취급하는 것이 좋다.
- 다른 knowledge는 분리해 두는 것이 좋다. 그렇지 않으면, 재사용해서는 안 되는 부분을 재사용하려는 유혹이 발생할 수 있다.



### ITEM20. 일반적인 알고리즘을 반복해서 구현하지 말라

p.119

- 이렇게 이미 있는 것을 활용하면, 단순하게 코드가 짧아진다는 것 이외에도 다양한 장점이 있다.

p.121

- 널리 알려진 추상화이므로 범용 유틸리티 함수로 정의하는 것이 좋다.
- 여러 번 사용되지 않는다고 해도 이렇게 만드는 것이 좋다.

p.122

- 따라서 필요 없는 함수를 중복해서 만들지 않게, 기존에 관련된 함수가 있는지를 탐색하는 과정이 필요하다.
- 수정할 객체를 아규먼트로 전달받아 사용하는 것 보다는 확장 리시버로 사용하는 것이 가독성 측면에서 좋다.
- 확장 함수는 객체에 정의한 함수보다 객체를 사용할 때, 자동 완성 기능 등으로 제안이 이루어지므로 쉽게 찾을 수 있다.

### ITEM21. 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라

p.126

- 프로퍼티 위임은 다른 객체의 메서드를 활용해서 프로퍼티의 접근자(게터와 세터)를 만드는 방식이다. 이때 다른 객체의 메서드 이름이 중요하다. 게터는 getValue, 세터는 setValue 함수를 사용해서 만들어야 한다.

p.129

- stdlib
  - lazy
  - Delegates.observable
  - Delegates.vetobale
  - Delegates.notNull

### ITEM22. 일반적인 알고리즘을 구현할 때 제네릭을 사용하라

p.130

- 함수에서는 fun 키워드와 함수 이름 사이에 \<T> 형태의 코드를 입력한다. 클래스와 인터페이스는 이름 뒤에 \<T> 형태의 코드를 입력한다.

p.131

- 타입 파라미터의 중요한 기능 중 하나는 구체적인 타입의 서브타입만 사용하게 타입을 제한하는 것이다.

### ITEM23. 타입 파라미터의 섀도잉을 피하라

p.135

- 타입 파라미터 섀도잉을 피하기 바란다. 타입 파라미터 섀도잉이 발생한 코드는 이해하기 어려울 수 있다. 타입 파라미터가 섀도잉되는 경우에는 코드를 주의해서 살펴보길 바란다.

### ITEM24. 제네릭 타입과 variance 한정자를 활용하라

여기어려움 ㅠ

### ITEM25. 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라

p.149

- 코틀린의 멀티 플랫폼 기능을 활용하면, 로직을 한 번만 구현하고, 두 플랫폼에서 이를 재사용할 수 있다.