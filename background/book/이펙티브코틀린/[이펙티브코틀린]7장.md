# 7장

p.303

- 장기적으로 보았을 때 효율성은 중요하다. 하지만 최적화는 쉬운 일이 아니다. 또한 최적화를 초기 단계에서부터 하는 것은 얻는것 보다 잃는 것이 많은 경우가 많다. 



### ITEM 45. 불필요한 객체 생성을 피하라

p.309

- mutable 객체는 캐시하지 않는다는 규칙을 지키는 것이 좋다.
- 캐시를 활용하는 팩토리 함수
  - 팩토리 함수는 캐시를 가질 수 있다. 팩토리 함수는 항상 같은 객체를 리턴하게 만들 수도 있다.
  - weakRefrence / SoftReference



p.311

- 무거운 객체를 외부 스코프로 보내기
  - 성능을 위한 굉장히 유용한 트릭으로, 무거운 객체를 외부 스코프로 보내는 방법이 있다. 

p.312

- 이 함수가 한 파일에 다른 함수와 함께 있을 때, 함수를 사용하지 않는다면 정규 표현식이 만들어지는 것 자체가 낭비이다. 이러한 경우에는 지현 초기화 하면 된다.

- 이처럼 프로퍼티를 지연되게 만드는 것은 무거운 클래스를 사용할 때 유용하다.

p.314

- 지연초기화
  - 처음 호출될 때 무거운 객체들의 초기화가 필요할 것
  - 지연되게 만들면 성능 테스트가 복잡해지는 문제가 있따

### ITEM 46. 함수 타입 파라미터를 갖는 함수에 Inline 한정자를 붙여라

p.317

- inline 한정자의 역할은 컴파일 시점에 함수를 호출하는 부분을 함수의 본문으로 대체하는 것이다.

p.318

- 타입 아규먼트에 reified 한정자를 붙여서 사용할 수 있다
- 함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다
- 비지역 리턴을 사용할 수 있다.

p.319

- 컴파일 하는 동안 본문이 실제로 대체되어 제네릭도 사용 가능
- 함수 호출과 리턴을 위해 점프하는 과정과 백스택을 추적하는 과정이 없다.

p.325

- 인라인 함수는 재귀적으로 동작할 수 없다.
- 인라인 함수는 더 많은 가시성 제한을 가진 요소를 사용할 수 없다.

p.328

- 인라인 한정자를 남용하면, 코드의 크기가 쉽게 커진다. 
- 서로 호출하는 인라인 함수가 많아지면, 코드가 기하급수적으로 증가하므로 위험하다.

### ITEm 47 인라인 클래스의 사용을 고려하라

p.331

- 인라인 클래스는 다른 자료형을 래핑해서 새로운 자료형을 만들 때 많이 사용한다. 
- 타입 오용으로 발생하는 문제를 막음

p.332

- 더 좋은 해결 방법은 타입에 제항늘 거는 것이다. 제한을 걸면 제네릭 유형을 잘못 사용하는 문제를 줄일 수 있다. 그리고 이때 코드를 더 효율적으로 만들려면 다음과 같이 인라인 클래스를 활용한다.

p.335

- 인터페이스를 구현하는 인라인 클래스는 아무런 의미가 없다.

### ITEM 48. 더 이상 사용하지 않는 객체의 레퍼런스를 제거하라

p.343

- 하지만 오브젝트에 null을 설정하는 것은 그렇게 어려운 일이 아니므로 무조건 하는것이 좋다.
- 예를 들어 코틀린 stdlib에 구현되어 있는 lazy 델리게이트는 사용 후에 모두 initializer를 null로 초기화한다.



