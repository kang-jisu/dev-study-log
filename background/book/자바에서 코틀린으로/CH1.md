### CH1

#### 1.2 코틀린의 결

- 코틀린은 가변 상태를 변경하는 것보다 불변 데이터를 변환하는 쪽을 더 선호한다.

- 코틀린은 동작을 명시적으로 작성하는 쪽을 더 선호한다.

  - 코틀린은 암시적인 타입 변환이 없음 

- 코틀린은 동적 바인딩보다 정적 바인딩을 더 선호한다. 

  - 클래스는 확장될 수 없고, 메서드는 다형적이지 않음

- 코틀린은 특별한 경우를 좋아하지 않는다.

  - 원시타입과 참조타입의 구분이 없음
  - Void 타입 없음. 코틀린 함수는 값을 반환하거나 아무것도 반환하지 않거나 둘 중 하나
  - 호출하는 쪽의 코드에서 기존 연산과 확장 함수 구분 x

- 코틀린은 마이그레이션을 쉽게 하기 위해 자신의 규칙을 깬다.

  - 코틀린 언어에는 숙어처럼 사용하는 자바와 코틀린 코드가 동시에 존재하도록 허용하기 위한 기능이 들어있음
  - `lateinit var ` 주의 필요 

  

#### 1.3 코틀린으로 리팩터링하기

- 코드 마이그레이션 + 비즈니스 만족 필요
  - 자바스러운 설계를 코틀린 구문으로 구현하는 것 부터 시작
  - 그 후 코틀린 언어 기능을 이용해 리팩토링

- `git bisect`
  - 테스트가 실패하는 첫 번째 커밋을 찾아줌
  - 각 리팩터링과 행동 변경을 서로 분리할 수 있도록 작게 초점을 맞춘 변경을 커밋함





### CH2. 자바 프로젝트에서 코틀린 프로젝트로

#### 2.1 전략

- 자바의 한계
  - 불변 값 타입을 구현하기 위해 필요한 장황한 코드
  - 원시 타입과 참조 타입의 분리
  - null 참조
  - 일반적인 고차 함수 지원이 부족한 스트림 
- 핵심 도메인 모델부터 시작
  - `data class ` 이용
  - 다른 클래스와 의존 관계가 없는 작은 값 클래스를 변환하는 것 부터 시작
  - 자바에서 새 기능을 변경하거나 추가할 때 마다 그 클래스를 코틀린 데이터 클래스로 변환하고, 변환 결과를 커밋한 다음, 코틀린으로 새 기능을 구현함



#### 2.2 코틀린 지원을 자바 빌드에 추가하기

- 코틀린을 그레이들 빌드에 추가하려면 코틀린 플러그인을 추가해야 한다. 
  - 코틀린 JVM 플러그인
  - 사용하려는 바이트코드 최소 버전에 맞는 JVM에 대한 코틀린 표준 라이브러리를 의존 관계에 추가해야 함
  - JDK11 <-> JDK 1.8 바이트코드  