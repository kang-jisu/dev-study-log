# 배열과 문자열

p.133

<br/>

## 해시테이블

효율적인 탐색을 위한 자료구조로서 키(key)를 값(value)에 대응시킨다. 

간단한 구현방식으로는 연결리스트와 해시 코드 함수만 있으면 된다. 키 값을 해시테이블에 넣을 때는 다음의 과정을 거친다.

1. 키의 해시코드를 계산한다. 키의 자료형은 보통 int혹은 long이 된다. 
   1. 키의 개수는 무한한데 반해 int의 개수는 유한하기 때문에 서로 다른 두개의 키가 같은 해시코드를 가리킬 수 있다는 사실을 명심하라.
2. hash(key)%array_lentgh 와 같은 방식으로 해시코드를 이용해 배열의 인덱스를 구한다. 
   1. 서로 다른 두개의 해시 코드가 같은 인덱스를 가리킬 수도 있다.
3. 배열의 각 인덱스에는 키 값으로 이루어진 연결리스트가 존재한다. 키와 값을 해당 인덱스에 저장한다. 
   1. 충돌에 대비해서 연결리스트를 이용해야한다. 
   2. 충돌이란 서로 다른 두개의 키가 같은 해시코드를 가리키거나, 서로 다른 두개의 해시코드가 같은 인데스를 가리키는 경우이다.

즉 **주어진 키 -> 해시코드 계산 -> 인덱스 계산 -> 연결리스트 탐색**

<br/>

충돌이 자주 발생한다면 최악의 경우 수행시간이 O(N)이 된다. (N개의 키가 존재할 때). 충돌을 최소화하도록 잘 구현된 경우 O(1)의 수행시간을 가진다. 

>  또다른 구현 방법으로는 균형이진탐색트리(Balanced binary search tree)를 사용하는 방법이 있다. 이경우 탐색시간은 O(logN)이 되고 크기가 큰 배열을 미리 할당해놓지 않아도 되기 때문에 잠재적으로 적은 공간을 사용한다는 장점이 있고, 키의 집합을 특정 순서로 차례대로 접근할 수 있어 어떤 경우에는 유용하다.  

  

### 해시테이블에서 충돌을 해결하는 방법 (p.814)

1. 연결리스트를 이용한 체이닝(chaining)

해시테이블의 각 원소가 연결리스트로 대응된 방법. 데이터를 연결리스트로 추가하면 된다. 

해시테이블에 n개의 원소가 있을 때 최악의 경우 O(n)시간이 걸린다. 이 경우는 데이터가 아주 이상하거나 해시 함수 성능이 나쁠때 발생한다. 

2. 이진 탐색 트리를 이용한 체이닝

충돌을 이진 탐색 트리에 저장한다. 최악의 경우 O(logN)의 수행시간이 된다. 

실제로는 데이터가 극단적으로 균일하게 분포되어 있지 않는 이상 <u>이 방법을 사용하지 않는다.</u>   



### 선형 탐사법을 이용한 개방 주소법 (p.814)

선형 탐사법(linear probing)을 이용한 개방 주소법(open addressing) 은 충돌이 발생했을 때 (주어진 인덱스에 이미 데이터가 들어가 있을 때) 비어있는 인덱스를 찾을 때 까지 다음 인덱스로 이동하는 방법을 말한다. (index+5처럼 고정된 크기 만큼 움직인다. )

장점 

- 충돌 횟수가 작을 때 이 방법은 아주 빠르고 공간 절약적이다. 

단점

- 해시테이블에 담을 수 있는 전체 데이터가 <u>배열 크기에 제한</u>된다는 단점이 존재한다. 
- 클러스터링, 특정 위치에 데이터가 몰리는 현상이 발생할 수 있다.

### 2차 탐색(quadratic probing)과 2중 해시(doubling hashing)

탐색할 때의 거리가 선형일 필요는 없다. 탐색 거리를 2차식으로 증가시키거나, 두번째 해시함수를 사용할 수도 있다. 소수값을 사용해 식을 만들면 클러스터링이 발생할 확률이 통계적으로 낮다. 

### Rabin-Karp 부분 문자열 탐색 알고리즘 (p.815)

길이가 긴 문자열 B에서 부분 문자열 S를 찾으려면 O(s(b-s))의 시간이 걸린다. 그 대신 B의 첫 b-s+1개의 문자만 검색하고 그 다음 s개의 문자가 S와 일치하는지 확인하면 된다.   

만약 두 문자열의 길이가 같다면 그들의 해시값은 같을 것이다. 따라서 B에서 길이가 s인 부분 문자열의 해시값을 사전에 계산하면, 가능한 S의 위치를 O(b)시간에 찾을 수 있다. 그 다음에는 위치가 실제로 S와 일치하는지 확인하면 된다. 

Hash(i) = Hash(i-1) - code[i-n] + code[i] (해시 값 = 해시값 - 가장 앞에있는 문자 + 새로 들어온 문자) 슬라이딩윈도우 방식으로 O(b)만에 해시값을 계산하면 평균적으로 O(s+b)만에 찾을 수 있다. 



## ArrayList와 가변 크기 배열

자바 언어의 경우 배열의 길이가 고정되어있다. 이런 경우에는 배열을 만들 때 배열 크기를 함께 지정해야한다. 

동적 가변 크기 기능이 내재되어있는 배열과 비슷한 자료구조를 원할 때는 ArrayList를 사용한다. ArrayList는 필요에 따라 크기를 변화시킬 수 있으면서도 O(1)의 접근시간을 유지한다. 

- 통상적으로 배열이 가득 차는 순간 배열 크기를 두배로 늘린다. 
- 크기를 두배로 늘리는 시간은 O(n)이지만 자주 발생하는 일이 아니라서 amortized inerstion time으로 계산했을 때 평균적으로 각 삽입은 O(1)이 된다. ( N개의 원소를 삽입하기 위해 1부터 2배씩 증가시키기 위해 복사하는 원소의 총 개수는 N/2+N/4+...+2+1로 N보다 작으므로 N개의 원소를 삽입할 때 소요되는 작업이 O(N)이다. )

## StringBuilder

문자열의 리스트가 주어졌을 때 문자열들을 하나로 이어붙이는데 수행시간은 ?

문자열을 이어붙일 때 마다 문자를 하나하나 새로운 문자열에 복사해야 하므로 O(N^2)이다. (1+2+3+...+N = N^2/2)

StringBuilder는 단순하게 가변 크기 배열을 이용해서 필요한 경우에만 문자열을 복사하게끔 해준다.

```java
String joinWords(String[] words ){
  StringBuilder sentence = new StringBuilder();
  for(String w : words) {
    sentence.append(w);
  }
  retun sentence.toString();
}
```

