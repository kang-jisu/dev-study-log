## 쿠버네티스 개요

### 쿠버네티스란 무엇인가

쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성있고, 확장가능한 오픈소스 플랫폼

- 쿠버네티스는 선언적 구성과 자동화를 모두 용이하게 해준다.
- 쿠버네티스는 크고 빠르게 성장하는 생태계를 가지고 있다.
- 쿠버네티스 서비스, 기술지원 및 도구는 어디서나 쉽게 이용할 수 있다.

**쿠버네티스 배경**

- 전통 배포 방식
  - 물리서버위에 여러 어플리케이션 배포
  - 리소스 할당 문제 발생
- 가상화 방식
  - 단일 물리서버의 CPU에서 여러 가상시스템을 실행할 수 있게 한다.
  - VM간에 애플리케이션을 격리하고 독립적인 환경으로 보안성을 제공할 수 있다.
  - 물리 서버에 리소스를 효율적으로 활용할 수 있으며 애플리케이션 추가,업데이트시 하드웨어 비용이 절감되어 더 나은 확장성을 제공한다.
  - VM은 가상화된 하드웨어 상에서 자체 운영체제를 포함한 모든 구성요소를 시행하는 하나의 완전한 머신이다.
- 컨테이너 개발 시대
  - VM과 유사하지만 격리 속성을 완화하여 애플리케이션간에 운영체제를 공유
  - 컨테이너에는 자체 파일시스템, CPU 점유율, 메모리, 프로세스 공간 등이 있다.
  - 기본 인프라와의 종속성을 끊어 클라우드나 OS배포본에 모두 이식할 수 있다.



**컨테이너 장점**

- 기민한 애플리케이션 생성과 배포 : VM이미지보다 이미지 생성이 쉽고 효율적이다.
- 지속적 개발, 통합, 배포 : 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있으며, 이미지의 불변성 덕에 빠르고 효율적으로 롤백할 수 있다.
- 개발과 운영의 관심사 분리 : 배포시점이 아닌 빌드/릴리즈 시점에 이미지를 만들기 때문에 애플리케이션이 인프라스트럭처에서 분리된다.
- 가시성 : OS수준을 넘어서 애플리케이션의 헬스(상태)와 그 밖의 시그널을 볼 수 있다.
- 개발, 테스팅 및 운영환경 일관성 : 어디서든 동일하게 구동된다.
- 클라우드 및 OS 간 이식성 : 리눅스 계열 Ubuntu, RHEL, CoreOS, 온프레미스, 퍼블릭크라우드 어디서든 구동된다.
- 애플리케이션 중심 관리 : 가상 하드웨어 상에서 OS를 실행하는 수준에서 논리적인 리소스를 사용하는 OS상에서 애플리케이션을 실행하는 수준으로 추상화수준이 높아진다.
- 느슨한 커플링, 분산, 유연하고 자유로운 마이크로서비스 : 애플리케이션은 단일 목적의 머신에서 모놀리식 스택으로 구동되지않고 작고 독립적인 단위로 쪼개져 동적으로 배포,관리될 수 있다.
- 리소스 격리 : 애플리케이션 성능 예측 가능
- 자원 사용량 : 리소스 사용량,, 고효율 고집적



**쿠버네티스 필요성**

쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임워크를 제공한다. 애플리케이션 확장과 장애 조치를 처리하고 배포 패턴 등을 제공한다.

- 서비스 디스커버리와 로드 밸런싱
  - DNS이름 , 자체 ip주소를 사용해 컨테이너 노출
  - 컨테이너의 트래픽에 따라 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어짐
- 스토리지 오케스트레이션
  - 원하는 저장소 시스템 자동 탑재
- 자동화된 롤아웃, 롤백
  - 컨테이너의 원하는 상태를 서술하여 현재 상태를 원하는 상태로 속도에 따라 변경할 수 있다.
- 자동화된 bin packing
  - 컨테이너 노드에 맞추어 리소스 사용
- 자동화된 복구(self-healing)
  - 실패한 컨테이너 재시작, 교체, 상태검사 등
- 보안과 구성관리
  - 암호, OAuth 토큰 및 ssh 키와 같은 중요한 정보를 젖아하고 관리할 수 있다.
  - 스택에 시크릿을 노출하지 않고도 구성을 따로 배포 및 업데이트할 수 있다.



**쿠버네티스는**

- 지원하는 애플리케이션의 유형을 제약하지 않는다.
  - stateless 워크로드, stateful 워크로드, 데이터 처리 워크로드 등
- 소스코드를 배포하거나 애플리케이션을 빌드하지 않는다.
- 애플리케이션 레벨의 서비스를 제공하지 않는다. 이런 서비스는 쿠버네티스 상에서 구동될 수 있다.

---



## 쿠버네티스 컴포넌트

- 모든 클러스터는 최소 한개의 워커노드
- 워커노드는 애플리케이션 구성요소인 파드를 호스트

![쿠버네티스 구성 요소](https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg)

### 컨트롤 플레인 컴포넌트

```
클러스터에 관한 전반적인 결정(예 , 스케쥴링)을 수행하고 클러스터 이벤트를 감지하고 반응
```

- kube-apiserver
  - API 서버는 쿠버네티스 API를 노출하는 컴포넌트
  - 컨트롤 플레인의 프론트엔드
- etcd
  - 모든 클러스터 데이터를 담는 뒷단의 저장소로 사용되는 일관성, 고가용성 키-값 저장소
- kube-scheduler
  - 노드가 배정되지 않는 파드 감지, 실행 노드 선택
  - 리소스 요구사항, 제약, 어피니티 명세, 지역성, 워크로드간 간섭 등 고려
- kube-controller-manager
  - 컨트롤러 프로세스 실행하는 컴포넌트
  - 노드컨트롤러
  - 레플리케이션 컨트롤러
  - 엔드포인트 컨트롤러
  - 서비스 어카운트 & 토큰 컨트롤러
- cloud-controller-manager ( 클라우드 제공자 전용 )
  - 클라우드별 컨트롤 로직을 포함하는 컴포넌트
  - 해당 클라우드 플랫폼과 상호작용하는 컴포넌트와 클러스터와만 상호작용하는 컴포넌트를 구분할 수 있게해줌

### 노드 컴포넌트

```
동작중인 파드를 유지시키고 쿠버네티스 런타임 환경을 제공하며 모든 노드상에서 동작한다.
```

- kubelet
  - 클러스터의 각 노드에서 실행되는 에이전트
  - kubelet은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.
  - PodSpec의 집합을 받아서 컨테이너가 해당 파드 스펙에 따라 건강하게 동작하는 것을 확실히한다. kubelet은 쿠버네티스를 통해 생성되지 않는 컨테이너는 관리하지 않는다.
- kube-proxy
  - 클러스터의 각 노드에서 실행되는 `네트워크 프록시`로 쿠버네티스의 서비스 개념의 구현부이다.
  - 노드의 네트워크 규칙을 유지 관리하고 네트워크 규칙이 내부 네트워크 세션이나 클러스터 바깥에서 파드로 네트워크 통신을 할 수 있도록 해준다.
  - 운영체제에 가용한 패킷 필터링 계층이 있는 경우 이를 사용하고, 그렇지 않으면 트래픽 자체를 포워드한다.
- 컨테이너 런타임
  - 컨테이너 실행을 담당하는 소프트웨어
  - containerd, CRI-O

### 애드온

```
애드온은 쿠버네티스 리소스(데몬셋, 디플로이먼트 등)을 이용하여 클러스터 기능을 구현한다.

이들은 클러스터 단위의 기능을 제공하기 때문에 애드온에 대한 네임스페이스 리소스는 kube-system 네임스페이스에 속한다.
```

- DNS
  - 모든 쿠버네티스 클러스터는 클러스터 DNS를 갖추어야한다.
  - 클러스터 DNS는 구성환경 내 다른 DNS 서버와 더불어 쿠버네티스 서비스를 위해 DNS레코드를 제공해주는 DNS서버다.
  - 쿠버네티스에 의해 구동되는 컨테이너는 DNS검색에서 이 DNS서버를 자동으로 포함한다.
- 웹 UI
- 컨테이너 리소스 모니터링
  - Horizontal Pod Autoscaler 컨트롤러나 Kubectl top 관련 메트릭
- 클러스터-레벨 로깅

---

## 쿠버네티스 API

```
컨트롤 플레인의 핵심 API 서버
최종 사용자, 클러스터의 다른 부분, 외부 컴포넌트가 서로 통신할 수 있도록 HTTP API 제공

쿠버네티스 API를 사용해 API 오브젝트와 이벤트를 질의,조작할 수 있다.
대부분 Kubectl , 또는 kubeadm을 이용해 수행하고 REST를 호출해 API에 직접 접근할수도 있다.
```

### 지속성

쿠버네티스는 오브젝트의 직렬화된 상태를 etcd에 기록하여 저장한다.