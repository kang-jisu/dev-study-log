> 개발자를 위한 레디스 튜토리얼 https://meetup.toast.com/posts/224
>
> 아직 잘 모르는데 따라쳐보면서 redis를 한번 알아보기 위해서,,,. 머리에 일단 스쳐지나가더라도 박고보기 ~ 



# Redis

> **RE**mote **DI**ctionary **S**erver

```
"파레토의 법칙"
인터넷 통신의 80%가 불과 20%의 사이트에 대한 액세스로 추정되며, 이 20%의 웹사이트 데이터를 캐시해두면 효율을 극적으로 향상시킬 수 있다.

따라서 공통으로 사용되는 데이터는 레디스를 이용하여 캐시로 저장해두는 것이 리소스를 효율적으로 이용할 수 있는 방법이 될 수 있다. 
```



### 특징

**In-Memory 데이터베이스**로 모든 데이터를 메모리에 저장하고 조회

- 메모리 접근이 디스크 접근보다 빠르므로, 관계형 DB보다 훨씬 빠름



**Collection**

```
String, Bitmap, Hash, List, Set, Sorted Set, Geospatial index, Hyperloglog, Stream 등의 자료형 지원
```

- **다양한 자료구조를 Key-Value형태로 저장** 
  - 다른 In-Memory 데이터베이스(Memcached)와 가장 큰 차이점은 **다양한 자료구조를 지원**한다는 점
    - Memcached는 문자열만 지원 (나머지는 거의 같음)
  - 개발의 편의성과 난이도에서 장점
    - EX) 실시간 랭킹 서버 구현
    - 관계형 DB : DB에 저장된 데이터를 SCORE로 불러와 정렬필요, 디스크를 사용하기 때문에 개수가 많아질 수록 속도가 느려짐
    - Redis : Sorted-Set을 이용하면 빠름
- 트랜잭션 문제 해결
  - 싱글 스레드로 동작하며 모든 자료구조는 atomic하여 race condition을 피해 데이터의 정합성을 보장



### 레디스의 자료 구조

**String**

- 키와 연결할 수 있는 가장 간단한 유형의 값
- 레디스의 키가 문자열이므로 이 구조는 문자열을 다른 문자열에 매핑하는 것

```bash
> set hello world
OK
> get hello
"world"
```

- 모든 종류의 문자열(이진데이터 포함)을 저장할 수 있음
  - JPEG 이미지, HTML fragment 캐시
- 저장 최대 사이즈 512MB

**List**

- 일반적인 Linked List의 특징
  - head, tail에 추가시 O(1)
- **Pub-Sub(생산자-소비자)패턴** 
  - 생산자가 아이템을 만들어서 list에 넣으면 소비자가 꺼내와서 액션을 수행
    - ex) 트위터의 타임라인

**Hash**

- field-value 쌍을 사용한 일반적인 해시 
- key에 대한 field의 개수에 제한이 없음 
- RDB의 table과 비슷 
  - hash key가 PK, field가 column, value가 value
  - key하나는 table의 한 row와 같다

**Set**

- 정렬되지 않은 문자열의 모음
- 아이템 중복 불가
- 교집합, 합집합, 차집합 연산을 레디스에서 수행할 수 있기 때문에 객체간의 관계를 표현할 때 좋다 

**Sorted Set**

- key하나에 중복되지 않는 여러 멤버를 저장하면서 각각의 멤버는 score에 연결된다.
- 이 값으로 정렬되어 스코어가 같다면 멤버 값의 사전순서로 정렬된다.
- sort가 필요한곳에 사용된다. 



### Redis Key

레디스 키는 문자열이므로 모든 이진 시퀀스를 키로 사용할 수 있다. String타입과 마찬가지로 허용되는 최대 키의 크기는 512MB

### Expire

in-memoy DB인 레디스인 만큼 메모리에 저장될 수 있는 데이터는 한정적이므로 데이터가 삭제될, 사용기한을 직접 설정해줌으로써 직접 사용 만료 시간을 정할 수 있다. `timeout` 사용 



## 캐시로써의 레디스

 ### Look Aside(=Lazy Loading)

![이미지](https://image.toast.com/aaaadh/real/2020/techblog/1%2810%29.png)  

캐시를 옆에 두고 필요할 때만 데이터를 캐시에 로드하는 캐싱 전략  

캐시는 DB와 어플리케이션 사이에 위치하여 단순 key-value형태를 저장한다. 어플리케이션은 데이터를 가져올 때 마다 레디스에 항상 먼저 요청하고, 데이터가 캐시에 있을 때는 레디스에서 데이터를 반환한다.  

데이터가 캐시에 없을 경우 어플리케이션에서 DB에 데이터를 요청하고 어플리케이션은 이 데이터를 다시 레디스에 저장한다. 

- 장점
  - 실제 사용되는 데이터만 캐시할 수 있음
  - 레디스의 장애가 애플리케이션에 치명적인 영향을 주지 않음 
- 단점
  - 캐시에 없는 데이터를 쿼리할 때 오랜시간이 걸림
  - 캐시가 최신 데이터를 갖고 있다는 것을 보장하지 못함





### Write-Through

![dklalwl](https://image.toast.com/aaaadh/real/2020/techblog/2%287%29.png)  

데이터베이스에 데이터를 작성할 때 마다 캐시에 데이터를 추가하거나 업데이트  

- 장점 
  - 캐시의 데이터는 항상 최신상태를 유지
- 단점
  - 데이터 입력시 두번의 과정을 거쳐야 하기 때문에 지연시간이 증가
  - 사용되지 않을 수도 있는 데이터도 캐시에 저장하여 리소스 낭비 발생
  - TTL(expire time)을 사용해 사용되지 않는 데이터 삭제 권장



### Write-Back

- 캐시의 데이터를 일정 주기마다 DB에 한번에 저장(배치)
- DB에 저장한 데이터를 캐시에서 제거 
- 서버 다운되면 데이터 사라짐 



### 레디스 영속성

레디스는 지속성을 보장하기 위해 데이터를 DISK에 저장할 수 있다. 

- RDB(Snapshotting)방식
  - 순간적으로 메모리에 있는 내용을 DISK 전체에 옮겨 담는 방식
- AOF(Append On File)방식
  - Redis의 모든 write/update연산 자체를 log파일에 기록하는 형태 



## 레디스 활용 사례

- 좋아요 처리하기
  - ![4.png](https://image.toast.com/aaaadh/real/2020/techblog/4%283%29.png)  
  - 게시물에 달린 댓글에 좋아요 표시 기능
  - 중요 포인트 : **하나의 댓글에 한번만 좋아요**를 할 수 있도록 제한
  - RDBMS라면 unique 조건으로 처리하겠지만, 많은 입력이 발생하는 환경에서 insert와 update에 의한 성능 저하가 발생할 것임 
  - 레디스의 `set` 을 이용하면 간단하게 구현할 수 있다. 
    - 순서가 없고 중복을 허용하지 않는 집합
    - 댓글의 번호를 사용해서 key를 생성하고 좋아요를 누른 사용자의 ID를 아이템으로 추가하면 한명의 사용자는 하나의 댓글에 한번만 좋아요를 누를 수 있다. 
- 게임 서비스에서 일일 순 방문자수(Unique Visitor) 구하기
  - ![5.png](https://image.toast.com/aaaadh/real/2020/techblog/5%283%29.png)
  - 사용자가 하루에 여러번 방문해도 한번만 카운팅
  - Redis의 `비트 연산` 사용 
    - 임의 유저 천만명, 일일 방문자 횟수를 0시기준으로 초기화하며 집계
    - 사용자 ID는 0부터 순차적으로 증가하고, string의 각 bit를 하나의 사용자로 생각
    - 사용자가 서비스에 방문할 때 사용자 ID에 해당하는 bit를 1로 설정 
    - 천만명의 유저는 천만개의 bit로 표현가능 -> 1.2MB
      - 레디스에서 string 최대 길이 512MB이므로 충분  
    - `BITCOUNT` 연산으로 간단히 1로 설정된 bit 개수 구할 수 있음
  - 출석 이벤트 등으로 정해진 기간동안 매일 방문한 사용자를 구하려면 `BITOP`이용해서 레디스 서버에서 바로 AND, OR, XOR, NOT 연산 가능 
    - ![6.png](https://image.toast.com/aaaadh/real/2020/techblog/6%283%29.png)
- 최근 검색 목록 표시
  - 관계형 데이터베이스라면
    - ​	`select * from KEYWORD where ID=123 order by reg_date desc limit 5;`
  - 중복 허용하지 않고, 정렬되어 저장되는 `sorted set`사용하면 간단하게 구현할 수 있다. 
    - 가중치를 기준으로 오름차순으로 정렬되기 때문에 가중치를 시간으로 사용한다면 값이 큰, 가장 최근 입력 아이템이 맨 마지막 인덱스에 저장될 것 
  - ![9.png](https://image.toast.com/aaaadh/real/2020/techblog/9%282%29.png)
    - 항상 5개만 저장할 때 양수로 인덱스를 설정한다면 0번을 지워야하는데 아이템의 개수가 6보다 작을 때는 0번을 지우면 안되므로 설정이 필요함. 이때 인덱스를 음수로 지정하면 매번 -6의 인덱스만 삭제하면 된다는 예시 그림 
    - 인덱스로 아이템을 지우는 커맨드는 `ZEMRANGEBYRANK`

​	



## Replication

>  레디스의 **HA(High Availability)**

- 레디스는 Master-Replica 형태의 복제를 제공한다.
- 복제연결이 되어있는 동안 마스터노드의 데이터는 실시간으로 리플리카 노드에 복사된다.
- 서비스를 제공하던 마스터노드가 다운되더라도 리플리카 노드에 어플리케이션을 재연결 해주면 서비스를 계속할 수 있다. 

![1.png](https://image.toast.com/aaaadh/real/2020/techblog/1%2811%29.png)  

- 한개의 마스터에 여러 리플리카 노드가 붙을 수 있고, 리플리카노드에 또 리플리카 노드가 연결되는 것도 가능

- 한개의 복제 그룹에서는 **항상 한개의 마스터 노드**만 존재 

- 마스터 노드의 IP가 127.0.0.1 , 포트가 6001일때 리플리카 노드에서 다음 커맨드를 실행하면 복제가 시작됨

  ``` bash
  > replicaof 127.0.0.1 6001
  ```

  - ![2.png](https://image.toast.com/aaaadh/real/2020/techblog/2%288%29.png). 
  - 마스터노드는 자식 프로세스를 만들어 백그라운드로 덤프파일을 만들고, 이를 네트워크를 통해 레플리카 노드인 B에 보낸다. 이 파일을 받은 노드 B는 데이터를 메모리로 로드한다. 
  - ![3.png](https://image.toast.com/aaaadh/real/2020/techblog/3%284%29.png)
  - 데이터 복제는 비동기방식으로 이루어짐 
  - 마스터에 데이터가 들어오면 마스터는 어플리케이션에 ACK을 보내고 그 다음 레플리카 노드에 데이터를 전달하기 때문에 마스터까지만 데이터가 입력된 후 마스터 노드가 죽는다면 데이터는 리플리카 노드까지 전달되지 않고 유실된다. (하지만 속도 매우 빨라서 유실이 자주 발생하진 않음)



## Sentinel

> In-memory database에서의 장애 위험성

레디스 프로세스가 다운되면 메모리에 저장되었던 데이터는 유실된다. 마스터 노드에 연결된 복제 노드가 있다면 데이터는 복제 노드에 남는데, 운영중인 서비스에서 어플리케이션이 마스터에 연결되어있는 상태였다면 다음 과정을 수행해야한다.

1. 복제 노드에 접속해서 `REPLICAOF NO ONE`을 통해 마스터 연결 해제
2. 어플리케이션 코드에서 레디스 연결설정을 변경 (마스터IP->복제노드IP)
3. 배포

하지만 실제 운영중인 서비스에서 이런 과정은 오래걸리고, 갑자기 많은 커넥션이 RDBMS에 몰려 서비스 장애로 이어질 수 있다.

**Sentinel 구성**

Sentinel은 마스터와 복제노드를 계속 모니터링 하며 장애 상황에는 복제 노드를 마스터로 승격시키기 위해 **자동 페일오버를 진행**한다. 특정 상황에 담당자에게 메일을 보내도록 알림설정을 할 수도 있다. 

![4.png](https://image.toast.com/aaaadh/real/2020/techblog/4%284%29.png) 

- 정상적인 기능을 위해 적어도 **세 개의 Sentinel 인스턴스 필요**
- 각 인스턴스는 레디스의 모든 노드를 감시하며 서로 연결되어있고, 세 대의 Sentinel 노드 중 과반수 이상이 동의해야만 페일 오버를 시작
- 어플리케이션은 마스터나 복제노드에 직접 연결하지 않고 Sentinel 노드에 연결해서 Sentinel 노드는 어플리케이션에게 현재 마스터의 IP, PORT를 알려주며 페일오버 이후에는 새로운 마스터의 IP, Port정보를 알려준다.



**FailOver 과정**

- ![5.png](https://image.toast.com/aaaadh/real/2020/techblog/5%284%29.png)
  - 마스터에 두개의 복제노드가 연결되어있음
  - 마스터가 다운되면 이를 감시하고 있던 Sentinel은 마스터에 진짜 연결할 수 없는지에 대한 투표 시작
- ![6.png](https://image.toast.com/aaaadh/real/2020/techblog/6%284%29.png)
  - 과반수 이상이 동의하여 페일오버 시작
  - 연결이 안되는 마스터에 대한 복제 연결을 끊고 복제노드중 한개를 선택하여 마스터로 승격시킴
  - 다른 복제 노드는 승격된 마스터 노드에 연결시킴
  - 다운되었던 마스터 노드가 살아난다면 새로운 마스터에 복제본으로 연결됨



## Cluster

> 레디스의 끝판왕 클러스터  
>
> 지금까지의 모든 장점에 **샤딩**이 더해짐  
>
> 레디스 클러스터의 특징은 **확장성, 고성능, 고가용성**  

- 데이터 셋을 여러 노드에 자동으로 분산 -> 확장성, 고성능
- 일부 노드가 다운되어도 계속 사용 가능 -> 고가용성

### Redis Cluster 구성

클러스터에서 모든 노드는 서로서로 연결된 Full Mesh 구조를 이루고 있다. 모든 마스터와 복제 노드는 서로 연결되어 가십 프로토콜을 이용해서 통신한다. 클러스터를 사용하기 위해서는 최소 세개의 마스터 노드가 필요하다. 

![8.png](https://image.toast.com/aaaadh/real/2020/techblog/8%283%29.png)  

### Sharding

어플리케이션으로부터 들어오는 모든 데이터는 해시슬롯에 저장된다. 레디스 클러스터는 총 16384개의 슬롯을 가지며 마스터 노드는 슬롯을 나누어 저장한다.   

마스터 노드가 세개일 때 아래처럼 해시 슬롯이 분배될 수 있음 

![9.png](https://image.toast.com/aaaadh/real/2020/techblog/9%283%29.png)  

- 노드 A는 0~5500
- 노드 B는 5501~11000
- 노드 C는 10001~16383

```
HASH_SLOT = CRC16(key) mod 16384
```

해시 슬롯은 마스터 노드 내에서 자유롭게 옮겨질 수 있으며 새로운 노드를 추가하거나 기존 노드를 삭제할 때 해시 슬롯을 이동시키기만 하면 되어 쉬운 확장 가능  

일반적으로 세 대의 마스터에 세 대의 복제노드를 연결하는 구성을 자주 사용한다. 

### FailOver

Sentinel과 마찬가지로 레디스 클러스터에서도 마스터 노드가 다운되면 이를 위해 연결된 복제노드를 마스터로 승격시키는 FailOver가 일어난다. 여기선 Sentinel 프로세스가 아닌 모든 노드가 서로서로를 감시한다.   

![11.png](https://image.toast.com/aaaadh/real/2020/techblog/11%282%29.png)  

- 가용성이 중요한 서비스에서 레디스 클러스터 구성을 이용할 때 노드를 하나 더 추가할 수 있다면 아무 마스터에 복제노드를 하나 더 연결시키면 좋음
  - 복제노드가 없는 마스터가 생기면 두개가 연결된 복제노드중 하나(A)를 B의 복제노드로 변경시키는 과정이 일어남	



### Client Redirection

클러스터 구조에서 마스터노드에 분할되어 저장될 때 어플리케이션은 샤딩을 생각하지 않고 아무 데로나 던져도 라이브러리와 레디스 서버가 알아서 해준다.   

- 잘못된 주소에 저장하면 리다이렉트 메세지 반환해서 다시 라이브러리는 제대로된 주소에 데이터를 저장시켜줌



## 레디스 이것만은 하지 마세요

### 요구사항 파악하기

- 캐시로 쓸 것인가 
- 저장소용으로 쓸 것인가

레디스에 저장되었던 데이터가 없어져도 같은 데이터가 RDBMS에 남아있기 때문에 문제가 없거나, 혹은 일부 값이 유실되어도 괜찮은지 확인해야한다. 레디스를 영구 저장소로 사용하는건 추천하지 않는다.   

![1.png](https://image.toast.com/aaaadh/real/2020/techblog/1%2812%29.png)



레디스는 싱글 쓰레드로 동작한다 (커맨드를 처리하는 쓰레드가 한개). **전체**를 다루는 커맨드는 주의해야함 

- 저장된 모든 값을 출력하는 커맨드 O(n)시간이 필요하므로 지양 	
  - KEYS *
- 메모리에 존재하는 전체 데이터 삭제 커맨드 
  - FLUSHALL / FLUSHDB
- 전체 메모리 내용 파일로 저장 
  - SAVE
- 레디스에 연결된 모든 클라이언트에서 보낸 모든 커맨드를 보여주는 커맨드 
  - MONITOR



### Redis.conf

레디스 설치 뒤 기본 파라미터 값을 그대로 사용하는 경우 생각지 못한 장애를 발생시킬 수 있음 



- 출처
  - Toast MeetUp https://meetup.toast.com/posts/227
  - 개발자를 위한 레디스 튜토리얼 01~04 