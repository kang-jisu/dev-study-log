# RunTime Data Area

JVM이 운영체제 위에서 실행되며 할당받은 메모리 영역이다. 

### 사전 지식

- JVM이 실행하기 위해서는 **바이트 코드들이 메모리 공간에 저장** 되어있어야 한다. 
- 어떤 메소드를 호출하는 문장을 만났을 때, 그 메소드를 가진 클래스의 바이트코드가 아직 로딩된 적이 없다면 JRE 라이브러리 폴더에서 클래스를 찾고, 없다면 CLASSPATH 환경변수에 지정된 폴더에서 클래스를 찾아 검증하고, 올바르다면 메소드 영역으로 파일을 로딩한다. 
- 이렇게 한번 JVM에 **로딩된 클래스의 바이트 코드는 JVM이 종료될 때 까지 유지**된다. 
- JVM은 처음 실행될 때 모든 클래스를 메모리에 올리는 것이 아니라, **필요할 때 마다 필요한 클래스를 메모리에 올려** 메모리를 효율적으로 관리한다. 
- **심볼릭 레퍼런스** - 8가지 원시타입(byte, short, int, long, float, double, char, boolean)을 제외한 모든 타입으로 정의된 변수는 레퍼런스 변수이다. 스택 메모리에서는 주소만 저장하고 힙 영역에 실제 그 변수가 가리키고 있는 값이 저장되어있다. 

<br/>

![img](https://tecoble.techcourse.co.kr/static/a0b18cc999920474a1852901e1e46ebf/6f641/2021-08-09-jvm-runtime-data-area-structure.png)

| Method <br />= Class<br />= Static<br />[RunTime Constant Pool] | Heap <br /><br /><br />[Eden,Survivor,Old,Permanet] | Stack | Native Method Stack | PC Register |
| ------------------------------------------------------------ | --------------------------------------------------- | ----- | ------------------- | ----------- |

영역을 5가지로 나누어 다시 정리해보려고 한다. 여기서 Method Area와 Heap Area는 모든 쓰레드가 공유하는 메모리 영역이며, Stack, Native Method Stack, PC Register는 쓰레드별로 생성되는 메모리 영역이다.

## 모든 쓰레드가 공유하는 메모리 영역

JVM이 시작될 때 실행되고, JVM이 종료되면 해제된다. 

### 1. Method Area 메서드 영역

- 클래스 정보를 처음 메모리로 올릴 때 초기화 되는 대상을 저장하기 위한 메모리 공간
- 클래스와 인터페이스에 대한 런타임 상수 풀, 멤버변수, 클래스 변수( 인스턴스 생성을 위해 필요한 모든 정보) 저장
  - 런타임 상수 풀 : 각 데이터의 reference를 가지고 있어서 실제 물리적 메모리 위치를 참조할때 사용하게 된다
  - Constant Pool : 상수 풀은 말그대로 상수를 저장하는 공간이다. 이외에도 필드나 메소드 등의 Reference값들을 저장하고 있어 실행중에 중복되는 정보가 필요할 때 기존의 정보를 사용하도록 도와준다.
- 메소드의 컴파일된 바이트 코드, static 변수가 저장되는 시점은 클래스가 메모리에 올라가는 시점이다.
- 이 영역에 등록된 class만이 Heap에 생성될 수 있다.  



##### Class Variable (클래스 변수)

- `static` 키워드로 선언된 변수를 의미
- 모든 인스턴스에 공유되며 인스턴스가 없어도 접근이 가능하다.
- 변수는 인스턴스가 아니라 클래스에 속하게 된다.
- 클래스를 사용하기 이전에 변수들은 미리 메모리를 할당받은 상태가 된다.
- final class 변수는 상수로 치환 되어 Runtime Constant Pool에 값을 복사한다.

> static은 JVM 메모리에 고정됨과 동시에 모든 객체가 공유한다는 의미를 뜻한다. 
>
> 인스턴스 변수의 값이 인스턴스마다 다른 값을 가질 수 있다는 점은 하나의 클래스를 여러개의 인스턴스로 만들어서 사용할 수 있다는 좋은 기능이다.
>
> 그러나 때에 따라 모든 인스턴스가 같은 값을 공유하게 하고 싶을 때가 있다. 이런 경우 해당 변수를 클래스의 멤버변수로 만들면 된다. 인스턴스 변수와 마찬가지로 class 내부에 위치하지만 static 키워드를 앞에 붙이면 클래스의 멤버가된다. 
>
> static이 실행되는 시점은 클래스가 메모리 상에 올라갈 때이다. 즉 프로그램을 실행하면 필요한 클래스가 JVM 메모리상에 로딩되는 과정을 거치고, 한번 로딩된 클래스는 메모리 상에서 객체를 생성할 수 있도록 메모리에 상주된다. static은 이 시점에 메모리에 올라가면서 필요한 동작을 처리한다. 결과적으로 static은 객체의 생성과 관계없이 클래스가 로딩되는 시점에 단 한번만 필요한 동작을 처리하기 위해 사용한다. 이때 JVM의 메소드영역(클래스 영역)에 클래스의 정보들이 올라가게된다. 
>
> 클래스 영역 = 메소드 영역 = 클래스 정보, 변수 정보, 메소드 정보, static 변수, 상수 풀 
>
> https://ict-nroo.tistory.com/19

### 2. 힙 영역

런타임시 `new` 명령어를 통해 생성된 인스턴스 변수가 동적으로 할당되는 영역

- 애플리케이션 영역에 접근할 수 있는 메모리의 메인 영역, Thread에서 공유하는 영역이므로 동기화 문제가 발생할 수 있다.

- 힙 영역에 생성된 객체, 배열을 스택 영역의 변수나 다른 객체의 필드에서 참조한다. 힙 영역에 보관되는 메모리는 메소드 호출이 끝나도 사라지지 않기 때문에 참조하는 변수나 필드가 없어 GC에 의해서 지워질 때 까지, 또는 JVM이 종료될 때 까지 남아있다.

#### 힙 영역 구분 5가지 (정리 예정)

- Eden ( Young Generation)
  - 객체가 생성되면 처음 저장되는 공간
  - 일정시간이 지나 Eden공간이 꽉차면 쓸모없는 데이터는 Minor GC에 의해 삭제되고 나머지는 Survivor1로 복사된다.
- Survivor 1& 2 (Yong Generation)
  - Eden에서 살아남은 데이터가 옮겨지며 공간이 부족해지면 쓸모없는 데이터는 Minor GC에 의해 삭제되고 Old데이터로 보내진다.
- Old ( tenured generation )
  - Young Generation에서 살아남은 객체가 저장되는 곳이다.
  - 굉장히 오래 사용하고 크기가 큰 객체가 대부분이며, Old의 공간이 꽉차면 Major GC가 실행된다. 
  - Major GC는 객체의 살아있는 여부를 모든 쓰레드의 실행을 멈추고 관리하기때문에 Minor에 비해 자원,시간 소모가 크다.
- Permanent
  - JDK8부터 삭제되어 해당 기능은 현재 Metaspace가 대신하고 있다. <추가정리필요>

<br/>

## 쓰레드 별로 별도 메모리가 생성되는 영역 

쓰레드가 생성될 때 메모리 영역이 같이 생성되며 쓰레드 종료시 해제된다.

### 1. 스택 영역

메서드를 호출할 때 메서드의 Stack Frame이 저장되는 영여그로, 스택 영역에는 지역변수(local variable, 메소드 내에서 선언된 변수)와 매개변수(parameter, 메소드에 넘겨준 값), 리턴값 등이 저장된다. 

기본 자료형 변수는 stack 영역에 저장되며 참조 자료형(기본 자료형 외 모두) 변수는 참조값(주소값)이 저장되어 Heap에 존재하는 실제 데이터를 참조한다.   

재귀 호출로 Stack overflowError(또는 JVM 메모리 부족으로 인한 OutOfMemoryError)가 발생할 수 있다.   

### 2. PC Register

프로그램의 실행은 CPU에서 명령어를 수행하는 과정으로 이루어지며, CPU는 이러한 명령어를 수행하는 동안 필요한 정보를 레지스터라고 하는 CPU내의 기억장치를 사용한다. 

하지만 JVM은 스택 기반으로 작동하기 때문에 CPU에 직접 명령어를 수행하지 않고 스택에서 Operand를 뽑아내어 별도의 메모리 공간에 저장하는 방식을 취하고있다. 이것이 PC Register이다. 이 공간을 CPU에게 Instruction으로 제공하게 된다. 

쓰레드가 Java 메서드를 수행하고 있으면 JVM 명령의 주소를 가지고 있게되며, native stack을 실행할 땐 사용되지 않고 undefined 상태로 있게된다.

### 3. Native Method Stack

Java 이외의 언어로 만들어진 코드를 위한 Stack

JNI (Java Native Interface)를 통해 호출되는 C/C++등의 코드를 수행하기 위한 Stack. JVM 내부 영향을 주지 않기 위해 따로 메모리 공간을 활용한다. 



- 출처
  - https://sgcomputer.tistory.com/64
  - https://blog.wanzargen.me/16
  - https://tecoble.techcourse.co.kr/post/2021-08-09-jvm-memory/
  - https://re-build.tistory.com/2
  - https://blog.embian.com/61?category=527619

----

//아직 정리 덜됨 

### 실행 엔진 / JIT 컴파일러

- 중복된 바이트 코드를 네이티브 언어로 모두 바꿔주는 컴파일러
- 인터프리터가 읽으면서 컴파일시키고 실행하다 중복되는 부분을 발견하면 JIT로 보내서 네이티브 언어로 바꿔준다.

- *interpreter* : 바이트코드를 한 줄씩 해석하여 실행합니다. 여기서 단점은 하나의 메소드를 여러 번 호출할 때 매번 해석이 필요하다는 것입니다.
- *Just-In-Time Compiler(JIT)* : 인터프리터의 효율성을 높이기 위해 사용합니다. 전체 바이트 코드를 컴파일하여 네이티브 코드로 변경하여 인터프리터가 반복되는 메서드 호출을 볼 때마다 JIT에서 해당 부분에 대한 직접 네이티브 코드를 제공하므로 재해석이 필요하지 않아 효율성이 향상됩니다.

- 출처
  -  https://goodncuteman.tistory.com/17?category=701749



---

클래스가 언제 로딩되는지에 대한 글 <정리필요 >



- 언제 클래스를 로딩하는가 ?
  - 클래스의 인스턴스가 생성될 때
  - 클래스의 정적 변수가 **사용될 때** : final로 선언된 상수 제외
  - 클래스의 정적 메소드가 호출 될 때
  - -verbose:class 옵션을 사용해 클래스 로딩을 디버그해보자.
  - https://velog.io/@skyepodium/%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%96%B8%EC%A0%9C-%EB%A1%9C%EB%94%A9%EB%90%98%EA%B3%A0-%EC%B4%88%EA%B8%B0%ED%99%94%EB%90%98%EB%8A%94%EA%B0%80 이 블로그 설명 잘돼있음 
- 클래스 초기화는 static 블록과 static 멤버 변수의 값을 할당하는 것을 의미한다. 내부의 클래스는 초기화 대상이 아니다.
  - 초기화 시점 
    - 클래스의 인스턴스 생성, 정적 메소드 호출, 정적 변수 할당, 정적 변수 사용 (클래스 로드 시점에 초기화가 바로 된다.)
  - 진행 순서
    - 정적 블록 -> 정적 변수 -> 생성자



