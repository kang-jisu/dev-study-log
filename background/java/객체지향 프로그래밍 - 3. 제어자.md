# 객체지향 프로그래밍 - 제어자(modifier)

- 내용 출처 자바의정석 3 (남궁성, 도우출판 )



## 제어자

클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 제어자는 접근제어자와 그 외의 제어자로 나뉘며 접근 제어자는 한번에 하나만 사용할 수 있다. 

```
접근 제어자 : public, protected, default, private
그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
```



### static - 클래스의, 공통적인

클래스변수(static 멤버 변수)는 인스턴스에 관계없이 같은 값을 갖는다. 그 이유는 하나의 변수를 모든 인스턴스가 공유하기 때문이다.  

static이 붙은 멤버변수와 메서드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이므로 인스턴스를 생성하지 않고도 사용할 수 있다. 또한 메서드 내에서 인스턴스 멤버를 사용할 수 없다. 

- static
  - 멤버변수
    - 모든 인스턴스에 공통적으로 사용되는 클래스 변수
    - 인스턴스 생성하지 않고도 사용 가능
    - 클래스가 메모리에 로드될 때 생성
  - 메서드
    - 인스턴스를 생성하지 안혹도 호출이 가능한 static 메서드
    - 메서드 내에서 인스턴스 멤버 사용 불가

 ### final - 마지막의, 변경될 수 없는

- 변수
  - 값을 변경할 수 없는 상수
- 메서드
  - 오버라이딩을 통한 재정의 불가
- 클래스
  - 변경될 수 없는 클래스. 확장될 수 없는 클래스
  - 자손 클래스 정의 불가 

**생성자를 이용한 final 멤버변수의 초기화**

final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스 변수의 경우 **생성자에서 초기화**되도록 할 수 있다. 이 기능을 활용하면 각 인스턴스마다 final이 붙은 멤버변수가 다른 값을 갖도록 하는것이 가능하다.   



### abstract - 추상의, 미완성의

- 메서드
  - 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.
- 클래스
  - 클래스 내에 추상 메서드가 선언되었음을 의미 

### 접근 제어자 

멤버 또는 클래스에 사용되어 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.  ( 기본값은 default)

| 접근 제어자 | 의미                                                         |
| ----------- | ------------------------------------------------------------ |
| private     | 같은 클래스 내에서만 접근 가능                               |
| default     | 같은 패키지 내에서만 접근 가능                               |
| protected   | 같은 패키지 내에서, 또는 다른 패키지의 자손 클래스에서 접근가능 |
| public      | 접근 제한 없음                                               |
|             |                                                              |

```
public > protected > (default) > private
```

**접근 제어자를 통한 캡슐화**

접근 제어자를 사용하는 이유 (데이터 감추기, **캡슐화**)

- 외부로부터 데이터를 보호하기 위해서
- 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서 

멤버변수를 private, protected로 제한하고 멤버변수의 값을 읽고 변경할 수 있는 public 메서드를 제공함으로써 간접적으로 멤버변수의 값을 다룰 수 있도록 하는것이 바람직하다.  

**생성자의 접근 제어자**

생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다. 대신 인스턴스를 생성해서 반환해주는 public 메서드를 제공함으로써 외부에서 이 클래스의 인스턴스를 사용하도록 할 수 있다. 이 메서드는 public인 동시에 static 이어야한다.  

 => **싱글톤 **, *생성자를 통해 직접 인스턴스를 생성하지 못하게 하고 public 메서드를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스의 개수를 제한한다.* 

```java

public class Singleton {
    
    // getInstance에서 사용할 수 있도록 인스턴스가 미리 생성되어야 하므로 static 이어야한다. 
    private static Singleton s = new Singleton();
    
    private Singleton(){
        //..
    }
    
    // 인스턴스를 생성하지 않고도 호출할 수 있어야 하므로 static 이어야한다. 
    public static Singleton getInstance(){
        return s;
    }
}

```

그리고 생성자가 private인 클래스는 자손 클래스의 인스턴스를 생성할 때 조상클래스의 생성자를 호출할 수 없으므로 상속이 불가능하다. 따라서 클래스 앞에 final을 추가하여 상속할 수 없는 클래스라는 것을 알리는것이 좋다. 

```java
final public class Singleton {

    // getInstance에서 사용할 수 있도록 인스턴스가 미리 생성되어야 하므로 static 이어야한다.
    private static Singleton s = new Singleton();

    private Singleton(){
        //..
    }

    // 인스턴스를 생성하지 않고도 호출할 수 있어야 하므로 static 이어야한다.
    public static Singleton getInstance(){
        if( s==null ){
            s = new Singleton();
        }
        return s;
    }
}
```





### 제어자의 조합

- 메서드에 static과 abstract를 함께 사용할 수 없다. 
  - static 메서드는 몸통이 있는 메서드에만 사용할 수 있다.
- 클래스에 abstract와 final을 동시에 사용할 수 없다.
  - final : 확장불가능, abstract: 상속을 통해 완성되어야함 => 모순
- abstract메서드의 접근 제어자가 private일 수 없다.
  - 자손클래스에서 구현해주어야하므로
- 메서드에 private과 final을 같이 사용할 필요는 없다.
  - 접근 제어자가 private인 메서드는 오버라이딩 할 수 없기 때문에 둘 중 하나만 사용해도 의미가 충분하다. 추상