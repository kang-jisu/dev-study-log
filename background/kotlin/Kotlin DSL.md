# DSL

> Domain Specific Language 

- 특정 과업, 영역에 초점을 맞추고 그 영역에 필요하지 않은 기능을 없앤 영역 특화 언어
- ex) SQL, 정규식
  - SQL 문장을 실행할 때 클래스나 함수를 선언하는 것 부터 시작하지 않고, 모든 SQL 문장은 첫 키워드가 수행하려는 연산의 종류를 지정하고, 각 연산은 처리해야 할 작업에 맞춰 각각 서로 다른 문법과 키워드를 사용한다. 



**<비교> 범용 프로그래밍 언어**

- 컴퓨터로 풀 수 있는 모든 문제를 충분히 풀수있는 기능을 제공
- ex) C, C++ 언어



### **DSL의 특징**

----

#### 선언적

선언적이다 <u><-></u> 명령적(범용 프로그래밍 언어)

- 어떤 연산을 완수하기 위해 필요한 각 단계를 순서대로 정확히 기술하는 명령적 언어와는 달리, **선언적 언어는 원하는 결과를 기술하기만 하고 세부 실행은 언어를 해석하는 엔진에 맡긴다.**
- 실행 엔진이 결과를 얻는 과정을 최적화 하기 때문에 선언적 언어가 더 효율적인 경우가 자주 있다. 

#### 단점

- DSL을 범용 언어로 만든 호스트 애플리케이션과 함께 조합하기가 어렵다. 
- DSL 자체의 문법을 가지고 작성한 프로그램을 다른 언어에서 호출하려면, DSL 프로그램을 별도의 파일이나 문자열 리터럴로 저장해야한다. 
  - 컴파일 시점 검증이 어려움
  - 디버깅이나 IDE 지원을 받기 어려움
  - 호스트 애플리케이션의 범용언어와 DSL 모두 익혀야함



### 내부 DSL

----

>  이러한 DSL의 단점을 해결하며, DSL의 다른 이점을 살리는 방법으로 내부 DSL이라는 개념이 나왔다.



- 내부 DSL이란 범용 언어로 작성된 프로그램의 일부이며, 범용 언어와 동일한 문법을 사용한다.
- DSL의 핵심 장점을 유지하며 주 언어를 특별한 방법으로 사용하는 것



#### 예제 [ 외부 DSL vs 내부 DSL ]

- 가장 많은 고객(Customer)이 살고 있는 나라(Country)를 알아내는 것



**외부 DSL (SQL)로 작성한 코드**

```sql
SELECT Country.name, COUNT(Customer.id)
 FROM Country
 JOIN Customer
  ON Country.id = Customer.country_id
GROUP BY Country.name
ORDER BY COUNT (Customer.id) DESC
  LIMIT 1
```



**내부 DSL (코틀린 Exposed)로 작성한 코드**

```kotlin
(Country join Customer)
  .slice(Country.name, Count(Customer.id))
  .selectAll()
  .groupBy(Country.name)
  .orderBy(Count(Customer.id), isAsc = true)
  .limit
```



실행하면 동일한 쿼리가 생성, 실행되지만, 작성할 때는 내부 DSL로 작성한 코드는 코틀린 코드이며, 코틀린 메서드이다.  

또한 쿼리를 실행한 결과가 네이티브 코틀린이기 때문에 SQL 질의가 돌려주는 결과를 코틀린 코드로 반환할 필요가 없다. 



이러한 것을 내부 DSL이라고 부른다. 코드는 어떤 구체적인 과업을 달성하기 위한 것이지만, 범용 언어의 라이브러리로 구현된다. 



- 출처
  - 코틀린 인 액션 11장 - DSL 만들기

----



코틀린 DSL의 예로 , Kotest나 Gradle(Groovy dsl, kotlin dsl)을 들 수 있다. 

- (참고) Kotest는 DSL을 지원하는 코틀린으로 만든 테스트 프레임워크이다. 

둘 다 코틀린 문법으로 만들어진 DSL이고, 타입에 안전하고 IDE의 지원을 받을 수 있다. 

코틀린을 이용해 간단하게 사용할 수 있고, 코드의 가독성이 올라간다. 하지만 내부적으로 어떤 동작을 하는지는 파악하기 어렵다. (코틀린 코드로 직접 그 테스트를 작성하거나 빌드를 하기 위해 코드를 짜는게 아니라 내부의 실행 엔진에 의해 동작되기 때문)

