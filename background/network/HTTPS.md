```
aws-hyoh 블로그의 HTTP 통신과정 쉽게 이해하기를 보고 작성한 글입니다.  

출처 - https://aws-hyoh.tistory/34 
```



# HTTPS

> HyperText Transfer Protocol Secure Socket Layer
>
> HTTP over TLS, HTTP over SSL, HTTP Secure

월드 와이드 웹의 통신 프로토콜인 HTTP 의 보안이 강화된 버전으로, HTTPS는 통신 인증과 암호화를 위해 개발되었다. 

HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다. 따라서 데이터의 적절한 보호를 보장한다. HTTPS의 기본 TCP/IP 포트는 443이다. 



## HTTPS의 추상적 통신 과정 ( 클라이언트는 서버를 믿지 않는다. )

- 서버가 진짜임을 인증하기 위해 공인기관으로부터 별도의 인증서를 받게되는데 이를 'SSL 인증서' 라고 한다. 

- 이 인증서를 통해 서버가 진짜임을 검증하게되면, 그 후부터 서로의 데이터를 어떻게 암호화할 것인지 협상하게 된다. 

- ```
  예)
  1. 성인이 된 지수는 동사무소에 가서 주민등록증을 발급받으며 지문정보를 등록한다.
  2. 동사무소는 지수한테 생년월일과 신상을 확인하고 지문을 등록하고 주민등록증을 발급해주었다.
  3. 술집에간 지수는 민증을 확인받는다.
  4. 민증으로는 확실하지 않아서 싸이패스로 지문 대조를 한다.
  5. 싸이패스 : 통과
  6. 올바른 손님임을 확인한 술집에서는 술을 제공해주었다.
  7. 지수는 술집에서 술을 시키면서 즐겼다 ~ 
  ```

- ```
  SSL 인증서<->주민등록증 지수<->서버 술집<->웹브라우저
  1. 서버 : 내가 만든 사이트를 웹브라우저들이 믿게 하고 싶으니 공인 인증기관인 CA에게 SSL인증서를 발급받아 신뢰를 얻자
  2. 인증기관(CA) : 제출하신 도메인과 사이트 정보를 검토한 결과 SSL인증서를 발급해드리겠습니다. 서버에 게시하세요
  3. 웹브라우저 : 서버에 접속했더니 SSL 인증서가 있네? 진짜인가
  4. 웹브라우저 : 발급한 인증기관에게 물어봐야겠다.
  5. 인증기관(CA) : 이건 제가 발급한게 맞고 이 인증서를 보유한 사이트도 쇼핑몰이 맞습니다.
  6. 웹브라우저와 서버 : SSL인증서를 확인했으니 우리 데이터를 어떻게 주고받을 지 협상해보자 ~ 
  ```

## SSL인증서 생성 방법

> 웹브라우저가 SSL인증서를 검증하는 방법, 웹브라우저와 서버가 데이터를 암호화하는 방법

**암호화**

데이터를 알아볼 수 없는 모습으로 변경하여 감추는 것, HTTPS에서는 Key를 이용해서 데이터를 암호화한다.

**복호화**

암호화된 데이터를 해독이 가능한 평문 데이터로 되돌리는 것. HTTPS에서는 Key를 이용해서 데이터를 복호화한다.

**KEY**

HTTPS에서는 Key가 없으면 데이터를 암호화할 수도 없고, 암호화된 데이터를 다시 풀어서 보는 작업인 복호화도 할 수 없다. 

**공개키**

- Public Key
- 공개 가능한 키로 암호화 과정에 참여하는 웹브라우저, 서버 같은 **Key 발행자** 뿐만 아니라 해커가 알아도 상관 없다
- **개인키와 쌍을 이루어 존재**
- 데이터를 암호화하는데 사용

**개인키**

- Private Key
- **Key 발행자만 갖는 키**
- **공개키와 쌍을 이루어 존재**
- 데이터를 복호화하는데 사용 

**대칭키**

- 공개키/개인키 처럼 복호화와 암호화에 각각 다른 키가 쓰이는것이 아닌, **암호화/복호화에 동일한 하나의 대칭키를 사용**



위의 과정에 Key를 더해 살펴본다.

```bash
1. 서버 : 한 쌍의 공개키와 개인키를 생성한다. 서버 내 사이트의 각종 정보와 자신의 공개키를 인증기관에게 전달하여 SSL인증서 생성을 요청한다.
2. 인증기관(CA) : SSL 인증서를 발급한다. 인증서에는 서버의 도메인을 비롯하여 서버임을 인증하는 각종 정보가 담긴다. 이때 인증기관은 자신만의 한쌍의 "공개키"와 "개인키"를 생성하고 SSL 인증서를 인증기관의 "개인키"로 암호화하여 서버에게 전달하고 서버는 이 SSL 인증서를 게시한다.
3. 웹브라우저 : 인증기관의 "개인키"로 암호화된 SSL 인증서를 서버로부터 전달받아 인증서가 진짜인지 검증해본다.
4-5. 웹브라우저 : 인증기관에서 공개하고 있는 인증기관의 "공개키"를 가져와 SSL 인증서를 복호화해본다. 복호화가 된다면 인증기관에서 발급한 인증서가 맞다. 복호화되어 인증서로부터 서버의 정보를 얻을 수 있으면 서버가 진짜임도 확인이 가능하다. 그리고 서버에 접속해 서버의 공개키를 확보했다. 
6. 웹브라우저, 서버 : 웹브라우저가 서버를 신뢰하고있고, 서버에게서 확보한 "서버의 공개키"로 웹브라우저는 실제 데이터 암호화에 사용할 "비밀키를 암호화"하여 전송한다. 
7. 서버 : 서버는 서버의 공개키로 암호화한 "비밀키를 자신의 개인키로 복호화"한다. 이제 웹브라우저와 서버는 동일한 대칭키(비밀키)를 보유하게 되었다. 
```



## SSL Handshake (TLS Handshake)

송신자와 수신자가 암호화 통신을 하기 위해 데이터를 암호화할 대칭키를 타인에게 노출시키지 않고 Client가 Server에게 전송하기 위한 연결과정 

![ssl](https://cf-assets.www.cloudflare.com/slt3lc6tev37/5aYOr5erfyNBq20X5djTco/3c859532c91f25d961b2884bf521c1eb/tls-ssl-handshake.png)    

출처 - cloudfare

- 파란색 3-way handshake
  - 맨 윗줄의 SYN, SYN+ACK, ACK은 암호화 협상에 앞서 TCP 기반 연결을 생성하기 위해 실시하는 과정
- 노란색이 SSL Handshake
  - 1. 암호화 알고리즘(Cipher suite)결정
    2. 데이터를 암호화할 대칭키(비밀키) 전달

### SSL Handshake

1. **ClientHello**

- Client가 Server에 연결을 시도하며 전송하는 패킷으로 자신이 사용가능한 Cipher Suite 목록, Session ID, SSL Protocol Version, Random byte등을 전달한다. 

```
// Cipher Suite 구성
TSL_ECDHE_RSA_WITH_AES_128_CBC_SHA

TLS : 프로토콜 ( SSL/TLS )
ECDME : 키 교환방식
RSA : 인증서 검증
AES_128: 대칭키 이용 블록 암호화
CBC : 블록 암호 운용방식
SHA : 메시지 인증(무결성)
```

2. **ServerHello**

- Client가 보내온 ClientHello packet을 받아 Cipher Suite중 하나를 선태한 다음 Client에게 알리며 자신의 SSL protocol version등도 같이 보낸다. 

3. **Certificate**

- Server가 자신의 SSL인증서를 Client에게 전달한다. 인증서 내부에는 Server가 발행한 공개키가 들어있다.   
- Client는 Server가 보낸 CA의 개인키로 암호화된 SSL인증서를 CA의 공개키를 사용하여 복호화한다. -> 인증서 검증
- 이후에 Client는 데이터 암호화에 사용할 대칭키를 생성한 후 SSL 인증서 내부에 들어있던 Server의 공개키를 이용해 암호화하여 Server에게 전송할것

4. Server Key Exchange / ServerHello Done

- Server Key Exchange
  - Server의 공개키가 SSL인증서 내부에 없는 경우 Server가 직접 전달함
- Server가 할일을 마쳤음을 전달 

5. **Client Key Exchange**

- 대칭키를 Client가 생성하여 SSL 내부에서 추출한 Server의 공개키를 이용해 암호화한 후 Server에게 전달한다. 
- **여기서 전달된 대칭키가 SSL handshake의 목적**

6. **Change Chiper Spec / Finished**

- Client, Server모두 통신준비가 다 되었음을 알리는 패킷. Finished를 보내 SSL Handshake종료 
- 이제 Client, Server모두 비밀키(대칭키)를 가지고 있어 통신에 주고받을 데이터를 암호화할 수 있다.



## CA ( Certificate Authority, 인증기관)

CA는 3계층, 2계층 형태를 띄고있다

1. Root CA ( 최상위 기관 )
   1. 모두가 신뢰하기로한 최상위 인증기관
   2. 인증서를 스스로 검증
2. Intermediate CA (중간 기관)
   1. SSL인증서를 생성하기 위해 서버의 공개키를 Intermediate CA에게 제출하면, CA가 각종 정보를 CA의 개인키로 암호화하고, 상위 기관에게 자신의 공개키를 제출하여 상위기관의 개인키로 또 암호화하고, .. Root CA에게 공개키를 전달해 Root CA가 인증서를 생성하는 식으로 되어있음.. (대충적음)

