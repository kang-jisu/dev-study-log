## 네 번째 요구사항 추가하기 - Querydsl

### 37강. Querydsl 도입하기

- JPQL과 Querydsl의 장단점
- Kotlin + Spring Boot + QueryDsl



```kotlin
    @Query("SELECT NEW com.group.libraryapp.dto.book.response.BookStatResponse(b.type, COUNT(b.id)) " +
            "from Book b GROUP BY b.type")
    fun getStats(): List<BookStatResponse>
```

- @Query 구문은 문자열이기 때문**에 버그를 찾기 어려움**
- JPQL 문법이 일반 SQL와 조금 달라 복잡한 쿼리를 작성할때 어려움
- 조건이 복잡한 **동적 쿼리를 작성**할 때 함수가 계속해서 늘어난다.
- 프로덕션 **코드 변경에 취약하다.**
  - 필드이름 findByXxx가 변경됐을 때



**Spring Data JPA와 Querydsl을 함께 사용하며 서로를 보완하자**

- Querydsl : 코드로 쿼리를 작성할 수 있게 해줌



**build.gradle에 추가하기**

- plugin

  - ```groovy
    id 'org.jetbrains.kotlin.kapt' version '1.6.21'
    ```

- dependencies

  - ```groovy
        implementation 'com.querydsl:querydsl-jpa:5.0.0'
        kapt("com.querydsl:querydsl-apt:5.0.0:jpa")
        kapt("org.springframework.book:spring-boot-configuration-processor")
    ```

- kapt랑 얘네들 뭐지??

  - build 하니깐 build/generated/source/kapt/main/.../QBook 이런게 생김
  -  ![스크린샷 2023-06-26 오후 11.55.27](/Users/jskang/Library/Application Support/typora-user-images/스크린샷 2023-06-26 오후 11.55.27.png)





**kapt란**

- kapt annotation processing for kotlin
- 코틀린이 자바의 어노테이션을 처리할 때 kotlin파일의 어노테이션 처리를 포함한다. 
- JVm을 가동시킬 때 Kotlin의 어노테이션을 포함시키기 위해 사용되는 플러그인



### 38강. Querydsl 사용하기 - 첫 번째 방법

- UserRepository가 UserRepositoryCustom을 상속받을 수 있도록 interface를 생성해줌
- UserRepositoryCustomImpl이 UserRepositoryCustom을 구현



- Querydsl사용하기 위해서 Configuration파일에 Bean등록

  - 

  ```kotlin
  @Configuration
  class QuerydslConfig(
          private val em: EntityManager
  ) {
  
      @Bean
      fun querydsl(): JPAQueryFactory {
          return JPAQueryFactory(em)
      }
  }
  ```

- Bean 주입 후 impl

  - 

  ```kotlin
  class UserRepositoryCustomImpl(
          private val queryFactory: JPAQueryFactory
  ) : UserRepositoryCustom {
      override fun findWithHistories(): List<User> {
          TODO("Not yet implemented")
      }
  }
  ```

- ```kotlin
      override fun findWithHistories(): List<User> {
          return queryFactory.select(user).distinct()
                  .from(user)
  //                .leftJoin(user.userLoanHistories)
                  .leftJoin(userLoanHistory).on(userLoanHistory.user.id.eq(user.id)).fetchJoin()
                  .fetch()
      }
  ```

  - fetchJoin: 앞의 조인을 fetchJoin으로 간주한다.



**장점**

- UserRepository 하나만 만들어서 두개 구현해서 쓸 수 있다

**단점**

- 인터페이스와 클래스를 항상 같이 만들어주어야 하는 것이 부담이고 번거롭다.



### 39강. Querydsl 사용하기 - 두 번째 방법

```kotlin
    fun getStats(): List<BookStatResponse> {
        return queryFactory.select(Projections.constructor(
                BookStatResponse::class.java,
                book.type,
                book.id.count()
        ))
                .from(book)
                .groupBy(book.type)
                .fetch()
    }
```



- Projections.constructor
  - 데이터의 특정 컬럼만을 가져오겠다.
  - 주어진 DTO의 생성자를 부름
  - 뒤에나오는 파라미터들이 생성자로 들어간다.
- groupBy
- fetch

**장점**

- 클래스를 하나만 만들면 돼서 간편하다

**단점**

- 필요에 따라 두 Repository를 모두 불러와야한다. (주입받아야한다. Service에서)



이 두 번째 방법을 좀 더 선호한다고 함



### 40강. UserLoanHistoryRepository를 Querydsl로 리팩토링하기

