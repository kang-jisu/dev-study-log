# 책임 할당하기

이번 장에서 살펴볼 GRASP 패턴은 책임 할당의 어려움을 해결하기 위한 답을 제시해줄 것이다.   
GRASP패턴을 이해하고 나면 응집도와 결합도, 캡슐화 같은 다양한 기준에 따라 책임을 할당하고 결과를 트레이드 오프 할 수 있는 기준을 배우게 될 것이다.   

## 책임 주도 설계를 향해
데이터 중심의 설계에서 책임 중심의 설계로 전환하기 위해서는 다음의 두 가지 원칙을 따라야한다.
- 데이터보다 행동을 먼저 결정하라
- <u>협력</u>이라는 문맥 안에서 <u>책임을 결정</u>하라.

### 데이터보다 행동을 먼저 결정하라
> 이 객체가 수행해야 하는 책임은 무엇인가 -> 이 책임을 수행하는데 필요한 데이터는 무엇인가   
> 책임 중심의 설계에서는 객체의 행동, 즉 책임을 먼저 결정한 후에 객체의 상태를 결정한다.   

### 협력이라는 문맥 안에서 책임을 결정하라
책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야한다.  
협력을 시작하는 주체는 메시지 전송자이기 때문에 협력에 적합한 책임이란 메시지 수신자가 아니라 메시지 전송자에게 적합한 책임을 의미한다.  
즉 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야 한다.  


## 책임 할당을 위한 GRASP 패턴
> General Responsibility Assignment Software Pattern
> : 일반적인 책임 할당을 위한 소프트웨어 패턴  
> : 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것

### 도메인 개념에서 출발하기
설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려 보는 것이 유용하다. 

### 정보 전문가에게 책임을 할당하라
애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것.   
이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고 메시지를 책임 질 첫 번째 객체를 선택하는 것으로 설계를 시작.   

1. 사용자에게 제공해야 할 기능 : 영화 예매   
애플리케이션은 영화를 예매할 책임이 있다. 이 책임을 수행하는데 필요한 메시지를 결정한다.   
*메시지를 전송할 객체는 무엇을 원하는가?*
> 예매하라

*메시지를 수신할 적합한 객체는 누구인가?*
책임을 정보전문가, 즉 책임을 수행하는데 필요한 정보를 알고 있는 객체에게 할당하라.   
단 , 여기서 정보를 '알고'있다고 해서 정보를 '저장'하고 있을 필요는 없다.  

> 상영(Screening) 객체는 예매에 필요한 정보를 알고 있을 것이다. 

2. 예매하라 메시지를 완료하기 위해서는 예매 가격을 계산하는 작업이 필요하다.   
> 가격을 계산하라  
> -> Movie

3. 할인 조건에 따라 영화가 할인 가능한지 판단해야한다.
> 할인 여부를 판단하라  
> -> DiscountCondition


### 높은 응집도와 낮은 결합도 
책임을 할당할 수 있는 다양한 대안들이 존재한다면 응집도와 결합도의 측면에서 더 나은 대안을 선택하는 것이 좋다.   
> 낮은 결합도 (LOW COUPLING) 패턴  

- 도메인 상으로 Movie는 DiscountCondition목록을 속성으로 포함하고 있다. Movie와 DiscountCondition은 이미 결합돼있기 때문에 둘이 협력하게 하면 설계 전체적으로 
결합도를 추가하지 않고도 협력을 완성할 수 있다.   
- 하지만 Screening과 DiscountCondition이 협력 할 경우에는 새로운 결합도가 추가된다.

> 높은 응집도 (HIGH COHESION) 패턴
- Screening의 가장 큰 책임은 예매를 생성하는 것이다. 만약 DiscountCondition과 협력해야한다면 영화 요금 계산과 관련된 책임의 일부를 떠안아야 할 것이다. 
- 반면 Movie의 주된 책임은 영화 요금을 계산하는 것이다. 

### 창조자에게 객체 생성 책임을 할당하라
영화 예매 협력의 최종 결과물은 Reservation 인스턴스를 생성하는 것이다.  
이것은 협력에 참가하는 어떤 객체에게는 Reservation 인스턴스를 생성할 책임을 할당해야 하는 것을 의미한다.  
GRASP의 **CREATOR(창조자) 패턴** 은 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다. 


> CREATOR 패턴
> - B가 A 객체를 포함하거나 참조한다.
> - B가 A객체를 기록한다.
> - B가 A객체를 긴밀하게 사용한다.
> - B가 A객체를 초기화하는 데 필요한 데이터를 가지고 있다. (이 경우 B는 A의 정보 전문가)  
> : 이미 결합되어 있는 객체에게 생성 책임을 할당하는 것은 전체적인 결합도에 영향을 미치지 않을 것이다.   

## 구현을 통한 검증
코드를 통해 변경의 이유를 파악할 수 있는 첫번째 방법 : **인스턴스 변수가 초기화 되는 시점**  
- 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.
  반면 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않은 상태로 남겨진다.
- 함께 초기화되는 속성을 기준으로 코드를 분리해야한다.   

코드를 통해 변경의 이유를 파악할 수 있는 두번째 방법 : **메서드들이 인스턴스 변수를 사용하는 방식**  
- 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다. 반면 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도는 낮다고 볼 수 있다.
- 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 분리해야 한다.  

###  타입 분리하기
DiscountCondition -> PeriodCondition, SequenceCondition 

### 다형성을 통해 분리하기 
Movie입장에서는 PeriodCondition, SequenceCondition이 아무 차이가 없다.  
= Movie의 입장에서 SequenceCondition, PeriodConditon이 동일한 책임을 수행한다는 것은 **동일한 역할**을 수행한다는 것을 의미한다.  
역할을 사용하면 객체의 구체적인 타입을 추상화 할 수 있다.

> 추상화 방법  
> - 클래스 사이에서 구현을 공유해야 한다면 추상 클래스  
> - 구현을 공유할 필요 없이 대체하는 객체들의 책임만 정의하고 싶다면 인터페이스 


> 다형성 패턴
> - 객체의 타입을 검사해서 타입에 따라 여러 대안을 수행하는 조건적인 논리를 사용하지 말라고 경고한다.   
> 대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하라고 권고한다.  

### 변경으로 부터 보호하기
DiscountCondition의 두 서브 클래스는 서로 다른 이유로 변경된다.  
새로운 조건을 추가하는 경우에도 DiscountCondition이라는 역할이 Movie로 부터 서브 클래스의 존재를 감춘다.  
이처럼 변경을 캡슐화하도록 책임을 할당하는 것을 **PROTECTED VARIATION(변경 보호) 패턴** 이라고 부른다.  

### Movie 클래스 개선하기

### 변경과 유연성 
새로운 할인 정책이 추가될 때 마다 인스턴스를 생성하고, 상태를 복사하고, 식별자를 관리하는 코드를 추가하는 일은
번거로울 뿐 아니라 오류가 발생하기 쉽다.  
해결 방법은 상속 대신 **합성**을 사용하는 것이다. 

-> Movie 상속 계층 안에 구현된 할인 정책을 독립적인 DiscountPolicy로 분리한 후 Movie에 합성.   


## 책임 주도 설계의 대안
- 최대한 빠르게 목적한 기능을 수행하는 코드를 작성한다. 
- 주의할 점은 코드를 수정한 후에 겉으로드러나는 동작이 바뀌어서는 안된다는 것이다.   
- 캡슐화를 향상시키고, 응집도를 높이고, 결합도를 낮추면서 동작은 그대로 유지해야한다.  

> 이처럼 이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것을
> **리팩터링(Refactoring)** 이라고 부른다. 

ch4의 ReservationAgency 코드를 보면, reserve 메서드의 길이는 너무 길고 이해하기도 어렵다.  
- 어떤일을 수행하는지 한 눈에 파악하기 어렵기 때문에 코드를 전체적으로 이해하는데 너무 많은 시간이 걸린다.  
- 하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.  
- 메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에 버그가 발생할 확률이 높다.   
- 로직의 일부만 재사용 하는 것이 불가능하다.  
- 코드를 재사용 하는 유일한 방법은 원하는 코드를 복사해 붙여넣기 하는 것 뿐이므로 코드 중복을 초래하기 쉽다.

-> 일단 데이터 중심으로 구현하면서 리팩터링하는 것도 훌륭한 결과물을 낳을 수도 있다. 


